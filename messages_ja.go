package main

// BugDescriptionJa is bug description
var BugDescriptionJa = map[string]string{
	"CNT_ROUGH_CONSTANT_VALUE":               "既知の定数の雑な値を見つけた\n\n<p>\nコードの明確さともっと良い正確さのために定義済みライブラリ定数を使用することを推奨します。\n</p>",
	"SKIPPED_CLASS_TOO_BIG":                  "解析するにはあまりにも大きいクラス\n\n<p>\nこのクラスは効率的に処理できないほど大きいです。また，エラーのために完全に解析されませんでした。\n</p>",
	"NOISE_NULL_DEREFERENCE":                 "null ポインタ間接参照に関する偽の警告\n\n<p>\n偽の警告です。\n</p>",
	"NOISE_METHOD_CALL":                      "メソッド呼び出しに関する偽の警告\n\n<p>\n偽の警告です。\n</p>",
	"NOISE_FIELD_REFERENCE":                  "フィールド参照に関する偽の警告\n\n<p>\n偽の警告です。\n</p>",
	"NOISE_OPERATION":                        "演算に関する偽の警告\n\n<p>\n偽の警告です。\n</p>",
	"DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE": "正確に表されない double から構築された BigDecimal\n\n<p>\nこのコードは10進数の数にうまく変換されない <code>double</code> 値から <code>BigDecimal</code> を作成しています。\nたとえば，Java で <code>new BigDecimal(0.1)</code> と書くと，0.1と正確に等しい <code>BigDecimal</code> (スケールが1でスケールなしの値が1) が作成されると思うかもしれませんが，\n実際には0.1000000000000000055511151231257827021181583404541015625と等しくなります。\n</p>\n<p>\nおそらく <code>BigDecimal.valueOf(double d)</code> メソッドの使用が望ましいです。<code>BigDecimal</code> (たとえば， <code>BigDecimal.valueOf(0.1)</code> は0.1を与えます) を作成するためには <code>double</code> の文字列表現を使用します。\n</p>",
	"DMI_DOH": "D'oh! 無意味なメソッド呼び出し\n\n<p>\nこの部分的なメソッド呼び出しは，検査から明らかな理由で意味がありません。\n</p>",
	"DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD":                                         "EasyMock メソッドへの役に立たない/無意味な呼び出し\n\n<p>\nこの呼び出しは EasyMock メソッドにどんなオブジェクトも渡さないので何もしません。\n</p>",
	"DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS":                   "コアプールサイズが0の ScheduledThreadPoolExecutor の作成\n\n<p>\nコアプールサイズが0の <code>ScheduledThreadPoolExecutor</code> は決して何も実行しません。\n最大プールサイズへの変更は無視されます。<br>\n(<a href=\"https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor-int-\">Javadoc</a>)\n</p>",
	"DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR": "ScheduledThreadPoolExecutor の最大プールサイズを変えようとする無駄な試み\n\n<p>\n<code>ScheduledThreadPoolExecutor</code> は <code>ThreadPoolExecutor</code> から継承されますが継承されたチューニングメソッドの一部は有用ではありません。\n特に，corePoolSize スレッドとアンバウンド形式のキューを使用する固定サイズプールとして動作するので，maximumPoolSize の調整は有用な効果がありません。<br>\n(<a href=\"https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html\">Javadoc</a>)\n</p>",
	"DMI_UNSUPPORTED_METHOD":                                                      "サポートされていないメソッドの呼び出し\n\n<p>\nこのメソッド呼び出しのすべてのターゲットは <code>UnsupportedOperationException</code> をスローします。\n</p>",
	"DMI_EMPTY_DB_PASSWORD":                                                       "空のデータベースパスワード\n\n<p>\nこのコードは空白または空のパスワードを使用してデータベース接続を作成しています。\nこれはデータベースがパスワードによって保護されていないことを示しています。\n</p>",
	"DMI_CONSTANT_DB_PASSWORD":                                                    "ハードコードされた定数データベースパスワード\n\n<p>\nこのコードはハードコードされた定数パスワードを使用してデータベース接続を作成しています。\nソースコードかコンパイルされたコードへアクセスできる人なら誰でも簡単にパスワードを知ることができてしまいます。\n</p>",
	"HRS_REQUEST_PARAMETER_TO_COOKIE":                                             "信頼できない入力から形成された HTTP cookie\n\n<p>\nこのコードは信頼できない HTTP パラメータを使用して HTTP クッキーを構築しています。\nこのクッキーが HTTP レスポンスに追加されるなら，HRS(HTTP レスポンス分割) 脆弱性を可能にします。<br>\n詳細は， <a href=\"http://en.wikipedia.org/wiki/HTTP_response_splitting\">http://en.wikipedia.org/wiki/HTTP_response_splitting</a> を参照してください。\n</p>\n<p>\nSpotBugs は，HRS の最も露骨で自明なケースだけを探します。\nSpotBugs が何かを発見したなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\nHRS を心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"HRS_REQUEST_PARAMETER_TO_HTTP_HEADER":                                        "HTTP レスポンス分割脆弱性\n\n<p>\nこのコードはHTTP ヘッダに HTTP パラメータを直接書き込んでいます。これは HRS(HTTP レスポンス分割) 脆弱性を可能にします。<br>\n詳細は， <a href=\"http://en.wikipedia.org/wiki/HTTP_response_splitting\">http://en.wikipedia.org/wiki/HTTP_response_splitting</a> を参照してください。\n</p>\n<p>\nSpotBugs は，HRS の最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\nHRS を心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"PT_RELATIVE_PATH_TRAVERSAL":                                                  "サーブレットの相対パストラバーサル\n\n<p>\nソフトウェアは，制限されたディレクトリ内にあるパス名を構築するためにHTTPリクエストのパラメータを使いますが，パラメータはそのディレクトリの外にある場所に解決できる「.」のようなシーケンスを適切に無効にしていません。<br>\n詳細は， <a href=\"http://cwe.mitre.org/data/definitions/23.html\">http://cwe.mitre.org/data/definitions/23.html</a> を参照してください。\n</p>\n<p>\nSpotBugs は，相対パストラバーサルの最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\n相対パストラバーサルを心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"PT_ABSOLUTE_PATH_TRAVERSAL":                                                  "サーブレットの絶対パストラバーサル\n\n<p>\nソフトウェアは，制限されたディレクトリ内にあるパス名を構築するためにHTTPリクエストのパラメータを使いますが，パラメータはそのディレクトリの外にある場所に解決できる「/abs/path」のような絶対パスシーケンスを適切に無効にしていません。<br>\n詳細は， <a href=\"http://cwe.mitre.org/data/definitions/36.html\">http://cwe.mitre.org/data/definitions/36.html</a> を参照してください。\n</p>\n<p>\nSpotBugs は，絶対パストラバーサルの最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\n絶対パストラバーサルを心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER":                                     "反射型クロスサイトスクリプティング脆弱性があるサーブレット\n\n<p>\nこのコードはサーブレットの出力に HTTP パラメータを直接書き込んでいます。これは反射型 XSS(クロスサイトスクリプティング) 脆弱性を可能にします。<br>\n詳細は， <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">http://en.wikipedia.org/wiki/Cross-site_scripting</a> を参照してください。\n</p>\n<p>\nSpotBugs は，XSS の最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\nXSS を心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"XSS_REQUEST_PARAMETER_TO_SEND_ERROR":                                         "反射型クロスサイトスクリプティング脆弱性がエラーページにあるサーブレット\n\n<p>\nこのコードはサーブレットのエラーページに <code>HttpServletResponse.sendError</code> を使用して HTTP パラメータを直接書き込んでいます。\n信頼できない入力を返すことは反射型 XSS(クロスサイトスクリプティング) 脆弱性を可能にします。<br>\n詳細は， <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">http://en.wikipedia.org/wiki/Cross-site_scripting</a> を参照してください。\n</p>\n<p>\nSpotBugs は，XSS の最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\nXSS を心配するなら，商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"XSS_REQUEST_PARAMETER_TO_JSP_WRITER":                                         "反射型クロスサイトスクリプティング脆弱性がある JSP\n\n<p>\nこのコードはJSP の出力に HTTP パラメータを直接書き込んでいます。これは XSS(クロスサイトスクリプティング) 脆弱性を可能にします。<br>\n詳細は， <a href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">http://en.wikipedia.org/wiki/Cross-site_scripting</a> を参照してください。\n</p>\n<p>\nSpotBugs は，XSS の最も露骨で自明なケースだけを探します。\nSpotBugs が何かを見つけたなら，ほぼ間違いなく SpotBugs が報告しない多くの脆弱性があるでしょう。\nXSS に関して心配しているなら商用の静的解析ツールかペネトレーションテストツールの使用を真剣に検討すべきです。\n</p>",
	"SW_SWING_METHODS_INVOKED_IN_SWING_THREAD":                                    "Swing メソッドは AWT イベントディスパッチスレッドから呼び出す必要がある\n\n<p>\n(<a href=\"http://web.archive.org/web/20090526170426/http://java.sun.com/developer/JDCTechTips/2003/tt1208.html\">From JDC Tech Tip</a>)<br>\nに解説されているとおり，Swing のメソッド， <code>show</code> メソッド， <code>setVisible</code> メソッド， <code>pack</code> メソッドは，フレームのための関連したピアを作成します。\nピアの作成で，システムはイベントディスパッチスレッドを作成します。\nこれが問題になることがあります。なぜなら <code>pack</code> メソッドと <code>validate</code> メソッドがまだ処理中でもイベントディスパッチスレッドがリスナに通知できるからです。\nこの状況は，2つのスレッドが Swing コンポーネントにアクセスする可能性があり，デッドロックや，その他のスレッドに関する問題になる可能性がある重大な欠陥です。\n<code>pack</code> メソッドの呼び出しはコンポーネントを実体化させます。実体化しているときに，イベントディスパッチスレッドがリスナへの通知を開始する可能性があります。\n</p>",
	"IL_INFINITE_LOOP":                                                            "明らかな無限ループ\n\n<p>\nこのループは，例外をスローする以外の方法で終了させることができないように思われます。\n</p>",
	"IL_INFINITE_RECURSIVE_LOOP":                                                  "明らかな無限再帰ループ\n\n<p>\nこのメソッドは，無条件で自分自身を呼び出します。これはスタックオーバーフローになる無限再帰ループを示しています。\n</p>",
	"IL_CONTAINER_ADDED_TO_ITSELF":                                                "コレクションは自分自身を追加している\n\n<p>\nコレクションは，自分自身を追加しています。その結果，hashCode を計算すると <code>StackOverflowException</code> をスローします。\n</p>",
	"VO_VOLATILE_REFERENCE_TO_ARRAY":                                              "配列への volatile 参照は，配列要素を volatile として扱わない\n\n<p>\n配列に <code>volatile</code> 参照を宣言していますが，あなたが望むものではないかもしれません。\n配列への <code>volatile</code> 参照は，配列への参照の読み出し，書き込みは <code>volatile</code> として扱われますが，配列要素は <code>volatile</code> として扱われません。\n配列要素を <code>volatile</code> として扱いたいのであれば，J2SE 5.0で提供された java.util.concurrent パッケージのアトミック配列クラスを使用する必要があります。\n</p>",
	"VO_VOLATILE_INCREMENT":                                                       "volatile フィールドへのインクリメントはアトミックではない\n\n<p>\nこのコードは <code>volatile</code> フィールドをインクリメントしています。\n<code>volatile</code> フィールドのインクリメントはアトミックではありません。\n複数のスレッドが同時にフィールドをインクリメントすると，インクリメントが失われる可能性があります。\n</p>",
	"UI_INHERITANCE_UNSAFE_GETRESOURCE":                                           "クラスが拡張されるなら getResource の使い方は安全ではないかもしれない\n\n<p>\nこのクラスが別のパッケージによって拡張されるなら， <code>this.getClass().getResource(...)</code> の呼び出しは予想外の結果をもたらす可能性があります。\n</p>",
	"NP_BOOLEAN_RETURN_NULL":                                                      "戻り型が Boolean のメソッドが明示的に null を返している\n\n<p>\n<code>Boolean.TRUE</code> ， <code>Boolean.FALSE</code> ， <code>null</code> を返すメソッドはいつ事故が起きてもおかしくないです。\nこのメソッドは，まるで論理型の値を返すかのように呼び出されます。\nコンパイラは <code>Boolean</code> 値のオートアンボクシングを挿入します。\n<code>null</code> 値が返されるなら <code>NullPointerException</code> が発生することになります。\n</p>",
	"NP_OPTIONAL_RETURN_NULL":                                                     "Optional の戻り型を持つメソッドが明示的に null を返す\n\n<p>\n<code>Optional</code> の戻り型 (<code>java.util.Optional</code> または <code>com.google.common.base.Optional</code>) の使い方で明示的に <code>null</code> を返すのは設計が望ましくないことを意味します。\n<code>null</code> 値をこのようなケースで返すことは契約違反で，多分クライアントコードを破壊するでしょう。\n</p>",
	"NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR":                             "非 null フィールドは初期化されていない\n\n<p>\nフィールドは，非 <code>null</code> としてマークされていますが，コンストラクタで書き込まれていません。\nフィールドは，コンストラクタの間，ほかの場所で初期化されるか，または使用する前に常に初期化されるかもしれません。\n</p>",
	"NP_SYNC_AND_NULL_CHECK_FIELD":                                                "同じフィールドでの同期化と null チェック\n\n<p>\nフィールドは同期化しているので，おそらく <code>null</code> ではないと思われます。\n<code>null</code> のフィールドを同期化すると <code>NullPointerException</code> がスローされるので， <code>null</code> チェックは無意味になります。\n別のフィールドで同期化したほうがよいです。\n</p>",
	"RpC_REPEATED_CONDITIONAL_TEST":                                               "条件テストの繰り返し\n\n<p>\nこのコードには条件テストが2回，つまり，1つめの条件テストが正しいとき，2つめの条件テストが実行されます (たとえば， <code>x == 0 || x == 0</code>)。\n多分，2つめの条件テストは何か他のことを意図しています (たとえば， <code>x == 0 || y == 0</code>)。\n</p>",
	"TESTING":                                                                     "テスト\n\n<p>\nこのバグパターンは，新しい不完全に実装されたバグディテクタによって生成されるだけです。\n</p>",
	"TESTING1":                                                                    "テスト1\n\n<p>\nこのバグパターンは，新しい不完全に実装されたバグディテクタによって生成されるだけです。\n</p>",
	"TESTING2":                                                                    "テスト2\n\n<p>\nこのバグパターンは，新しい不完全に実装されたバグディテクタによって生成されるだけです。\n</p>",
	"TESTING3":                                                                    "テスト3\n\n<p>\nこのバグパターンは，新しい不完全に実装されたバグディテクタによって生成されるだけです。\n</p>",
	"UNKNOWN":                                                                     "未知のバグパターン\n\n<p>\n警告が記録されたのに SpotBugs はこのバグパターンの説明を見つけることができなかったので警告について説明できません。\nこれは SpotBugs かその設定のバグの場合だけで発生させるべきです。\nまたは解析プラグインを使用して生成されるなら，プラグインは現在ロードされていません。\n</p>",
	"AM_CREATES_EMPTY_ZIP_FILE_ENTRY":                                             "空の ZIP ファイルエントリの作成\n\n<p>\nこのコードは <code>putNextEntry</code> メソッドを呼び出して， <code>closeEntry</code> メソッドをすぐにを呼び出しています。\nこれは空の ZIP ファイルエントリになります。\nエントリデータは <code>putNextEntry</code> メソッドと <code>closeEntry</code> メソッドの呼び出しの間で ZIP ファイルに書き込むべきです。\n</p>",
	"AM_CREATES_EMPTY_JAR_FILE_ENTRY":                                             "空の JAR ファイルエントリの作成\n\n<p>\nこのコードは <code>putNextEntry</code> メソッドを呼び出して， <code>closeEntry</code> メソッドをすぐに呼び出しています。\nこれは空の JAR ファイルエントリになります。\nエントリデータは <code>putNextEntry</code> メソッドと <code>closeEntry</code> メソッドの呼び出しの間で JAR ファイルに書き込むべきです。\n</p>",
	"IMSE_DONT_CATCH_IMSE":                                                        "疑わしい IllegalMonitorStateException のキャッチ\n\n<p>\n<code>IllegalMonitorStateException</code> は，一般的に設計上の欠陥 (ロックを保持していないオブジェクトで <code>wait</code> メソッドまたは <code>notify</code> メソッドを呼び出す) の場合にだけスローされます。\n</p>",
	"FL_MATH_USING_FLOAT_PRECISION":                                               "浮動小数点精度を使用した計算をしている\n\n<p>\nこのメソッドは，浮動小数点精度を使用して計算をしています。浮動小数点精度は非常に不正確です。\nたとえば， <code>16777216.0f + 1.0f = 16777216.0f</code>。\nその代わりに <code>double</code> の使用を検討してください。\n</p>",
	"CAA_COVARIANT_ARRAY_FIELD":                                                   "フィールドへの共変配列代入\n\n<p>\n共変型の配列がフィールドに割り当てられています。\n紛らわしくて，次のコードのように他の型の参照が後で配列に格納されるなら，実行時に <code>ArrayStoreException</code> を引き起こすことがあります。\n</p>\n<pre><code>Number[] arr = new Integer[10];\narr[0] = 1.0;\n</code></pre>\n<p>\n作成した配列の型またはフィールド型を変更することを検討してください。\n</p>",
	"CAA_COVARIANT_ARRAY_LOCAL":                                                   "ローカル変数への共変配列代入\n\n<p>\n共変型の配列がローカル変数に割り当てられています。\n紛らわしくて，次のコードのように他の型の参照が後で配列に格納されるなら，実行時に <code>ArrayStoreException</code> を引き起こすことがあります。\n</p>\n<pre><code>Number[] arr = new Integer[10];\narr[0] = 1.0;\n</code></pre>\n<p>\n作成した配列の型またはローカル変数型を変更することを検討してください。\n</p>",
	"CAA_COVARIANT_ARRAY_RETURN":                                                  "共変配列がメソッドから返される\n\n<p>\n共変型の配列がメソッドから返されます。\n呼び出し元のコードが返された配列に他の型の参照を格納しようとするなら，実行時に <code>ArrayStoreException</code> を引き起こすことがあります。\n</p>\n<p>\n作成した配列の型またはメソッドの戻り型を変更することを検討してください。\n</p>",
	"CAA_COVARIANT_ARRAY_ELEMENT_STORE":                                           "おそら互換性のない要素をく共変配列に格納している\n\n<p>\n配列に格納していてる値の型が配列型と一致していません。\n実際の配列型が宣言された変数またはフィールドの型よりも狭くなっていて，この割り当てがオリジナルの配列型を満たしていないことが解析でわかっています。\nこの割り当ては実行時に <code>ArrayStoreException</code> を引き起こすことがあります。\n</p>",
	"CN_IDIOM":                                                                    "Cloneable を実装したクラスが clone メソッドを定義も使用もしていない\n\n<p>\nこのクラスは， <code>Cloneable</code> を実装していますが， <code>clone</code> メソッドを定義も使用もしていません。\n</p>",
	"CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE":                                       "Cloneable を実装していないクラスが clone メソッドを定義している\n\n<p>\nこのクラスは， <code>Cloneable</code> を実装していないのに <code>clone</code> メソッドを定義しています。\nこれが OK (たとえば，サブクラスのクローンの実装を自分自身で制御したい場合です) という状況もありますが意図したことなのか確認してください。\n</p>",
	"CN_IDIOM_NO_SUPER_CALL":                                                      "clone メソッドが super.clone() を呼び出していない\n\n<p>\nこの非 <code>final</code> クラスは， <code>super.clone()</code> を呼び出さない <code>clone</code> メソッドを定義しています。\nクラス <i>A</i> がサブクラス <i>B</i> によって拡張され，サブクラス <i>B</i> が <code>super.clone()</code> を呼び出すなら，クラス <i>B</i> の <code>clone</code> メソッドは，型 <i>A</i> のオブジェクトを返す可能性が高いです。\nこれは <code>clone</code> のための汎用規約に違反します。\n</p>\n<p>\nすべての <code>clone</code> メソッドが <code>super.clone()</code> を呼び出すなら <code>Object.clone()</code> が呼び出されることが保証され，常に正しい型のオブジェクトが返されます。\n</p>",
	"NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER":                                        "Java の後のバージョンのキーワードである識別子を使用している\n\n<p>\n識別子は，Java の後のバージョンのキーワードとして予約されている単語です。\nコードを Java の後のバージョンでコンパイルするためには変更する必要があります。\n</p>",
	"NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER":                                 "Java の後のバージョンのキーワードである識別子を使用している\n\n<p>\nこの識別子は，Java の後のバージョンのキーワードとして使われます。\nこのコードと API を参照するどんなコードも，Java の後のバージョンでコンパイルするためには変更する必要があります。\n</p>",
	"DE_MIGHT_DROP":                                                               "例外を捨てているかもしれないメソッド\n\n<p>\nこのメソッドは，例外を捨てているかもしれません。\n一般的にキャッチした例外は何らかの方法で処理または報告すべきです。またはメソッドからスローすべきです。\n</p>",
	"DE_MIGHT_IGNORE":                                                             "例外を無視しているかもしれないメソッド\n\n<p>\nこのメソッドは例外を無視しているかもしれません。\n一般的に例外は何らかの方法で処理または報告すべきです。またはメソッドからスローすべきです。\n</p>",
	"DP_DO_INSIDE_DO_PRIVILEGED":                                                  "doPrivileged ブロック内で呼び出すべきメソッド\n\n<p>\nこのコードはセキュリティ許可チェックが必要なメソッドを呼び出しています。\nこのコードにセキュリティ許可が与えられるとしても，セキュリティ許可を持たないコードによって呼び出されるなら <code>doPrivileged</code> ブロックの中で呼び出す必要があります。\n</p>",
	"DP_DO_INSIDE_DO_PRIVILEDGED":                                                 "Method invoked that should be only be invoked inside a doPrivileged block\n\n<p> This code invokes a method that requires a security permission check.\n  If this code will be granted security permissions, but might be invoked by code that does not\n</p>",
	"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED":                                  "doPrivileged ブロック内で作成されるべきクラスローダ\n\n<p>\nこのコードはクラスローダを作成していますが，セキュリティ管理がインストールされるなら許可が必要です。\nこのコードがセキュリティ許可がないコードによって呼び出されるなら，クラスローダの作成は <code>doPrivileged</code> ブロックの中で行う必要があります。\n</p>",
	"JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS":                                    "不変クラスのフィールドは final にすべき\n\n<p>\nクラスは， <code>net.jcip.annotations.Immutable</code> または <code>javax.annotation.concurrent.Immutable</code> というアノテーションが付けられています。\nアノテーションのルールは，すべてのフィールドが <code>final</code> であることを義務付けます。\n</p>",
	"DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED":                                   "Thread オブジェクトが Runnable が期待されているところに渡されている\n\n<p>\n<code>Thread</code> オブジェクトが <code>Runnable</code> が期待されているメソッドへのパラメータとして渡されています。\nこれはかなり異常で，論理エラーを示すか，予想外の振る舞いの原因になることがあります。\n</p>",
	"DMI_COLLECTION_OF_URLS":                                                      "URL の Map や Set はひどい性能になる\n\n<p>\nこのメソッドまたはフィールドは， <code>URL</code> の <code>Map</code> か <code>Set</code> を使用しています。\n<code>URL</code> の <code>equals</code> と <code>hashCode</code> は，ドメイン名の解決を行うので，ひどい性能になります。<br>\n詳細は， <a href=\"http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> を参照してください。<br>\nその代わりに <code>java.net.URI</code> を使用することを検討してください。\n</p>",
	"DMI_BLOCKING_METHODS_ON_URL":                                                 "URL の equals メソッドと hashCode メソッドはブロックする\n\n<p>\n<code>URL</code> の <code>equals</code> メソッドと <code>hashCode</code> メソッドは，ドメイン名の解決を行うので，ひどい性能になる可能性があります。<br>\n詳細は， <a href=\"http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html\">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> を参照してください。<br>\nその代わりに <code>java.net.URI</code> を使用することを検討してください。\n</p>",
	"DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION":                                 "ランタイムリテンションなしで，アノテーションの存在を調べるためにリフレクションを使用することはできない\n\n<p>\nアノテーションに <code>@Retention(RetentionPolicy.RUNTIME)</code> アノテーションが付いていなければ，リフレクション (たとえば， <code>isAnnotationPresent(...)</code> メソッド) を使用して観測することができません。\n</p>",
	"DM_EXIT":                                                  "System.exit(...) を呼び出しているメソッド\n\n<p>\n<code>System.exit(...)</code> を呼び出すことは，Java 仮想マシン全体をシャットダウンさせてしまいます。\nそれが適切な場合にだけ使用すべきです。\n<code>System.exit(...)</code> の呼び出しは，他のコードによる呼び出しを困難か不可能にします。\nその代わりに <code>RuntimeException</code> をスローすることを検討してください。\n</p>",
	"DM_RUN_FINALIZERS_ON_EXIT":                                "危険なメソッド runFinalizersOnExit を呼び出しているメソッド\n\n<p>\nどんな理由があるにせよ決して <code>System.runFinalizersOnExit</code> と <code>Runtime.runFinalizersOnExit</code> を呼び出さないでください。\nJava ライブラリで最も危険なメソッドの1つです。 -- Joshua Bloch\n</p>",
	"DM_STRING_CTOR":                                           "効率が悪い new String(String) コンストラクタを呼び出しているメソッド\n\n<p>\n<code>new String(String)</code> コンストラクタの使用はメモリを浪費します。\nそのようにして構築されたオブジェクトと パラメータとして渡された <code>String</code> は機能的に区別がつかないからです。\n引数の <code>String</code> をそのまま使用してください。\n</p>",
	"DM_STRING_VOID_CTOR":                                      "効率が悪い new String() コンストラクタを呼び出しているメソッド\n\n<p>\n引数がないコンストラクタを使用して，新しい <code>java.lang.String()</code> オブジェクトを作成するとメモリを浪費します。\nそのようにして作成されたオブジェクトと空の文字列定数 <code>\"\"</code> は機能的に区別がつかないからです。\nJavaは，同一の文字列定数が同じ <code>String</code> オブジェクトによって表されることを保証します。\nしたがって，直接空の文字列定数を使用すべきです。\n</p>",
	"DM_STRING_TOSTRING":                                       "String の toString メソッドを呼び出しているメソッド\n\n<p>\n<code>String.toString()</code> を呼び出すのは冗長です。<code>String</code> を使用してください。\n</p>",
	"DM_GC":                                                    "明示的なガベージコレクション\n\n<p>\n明示的にガベージコレクションを呼び出しています。ベンチマークの特定の用途を除いて非常に疑わしいです。\n</p>\n<p>\n過去に， <code>close</code> メソッドや <code>finalize</code> メソッドでガベージコレクタを明示的に呼び出していた状況は，巨大なパフォーマンスブラックホールの原因となりました。\nガベージコレクションは高くつきます。何百，何千ものガベージコレクションを強制する状況は，システムの停滞をもたらすでしょう。\n</p>",
	"DM_BOOLEAN_CTOR":                                          "効率が悪い Boolean コンストラクタを呼び出しているメソッド\n\n<p>\n<code>java.lang.Boolean</code> の新しいインスタンスを作成するとメモリを浪費します。\n<code>Boolean</code> オブジェクトは不変で，2つの有用な値 (<code>Boolean.TRUE</code> と <code>Boolean.FALSE</code>) があります。\nその代わりに <code>Boolean.valueOf</code> メソッド (または J2SE 5.0 のオートボクシング) を使用して <code>Boolean</code> オブジェクトを作成してください。\n</p>",
	"DM_NUMBER_CTOR":                                           "効率が悪い Number コンストラクタを呼び出しているメソッド\n\n<p>\n<code>new Integer(int)</code> の使用は，常に新しいブジェクトになることが保証されています。\nこれに対して， <code>Integer.valueOf(int)</code> は，コンパイラ，クラスライブラリ，Java 仮想マシンで値がキャッシュされます。\nキャッシュに格納された値を使用することはインスタンスの作成を回避し，コードはより高速になります。\n</p>\n<p>\n-128から127までの値は対応するキャッシュされたインスタンスを持つことが保証されています。\nそして， <code>valueOf</code> メソッドの使用は，コンストラクタを使用するより約3.5倍高速です。\n定数範囲外の値は，両方のスタイルの性能は同じです。\n</p>\n<p>\nクラスが J2SE 5.0より前の Java 仮想マシンとの互換性が不要なら， <code>Long</code> ， <code>Integer</code> ， <code>Short</code> ， <code>Character</code> ， <code>Byte</code> のインスタンスを作成するときは，オートボクシングか <code>valueOf</code> メソッドを使用してください。\n</p>",
	"DM_FP_NUMBER_CTOR":                                        "効率が悪い浮動小数点 Number コンストラクタを呼び出しているメソッド\n\n<p>\n<code>new Double(double)</code> の使用は，常に新しいブジェクトになることが保証されています。\nこれに対して， <code>Double.valueOf(double)</code> は，コンパイラ，クラスライブラリ，Java 仮想マシンで値がキャッシュされます。\nキャッシュに格納された値を使用することはインスタンス生成を回避し，コードはより高速になります。\n</p>\n<p>\nクラスが J2SE 5.0より前の Java 仮想マシンとの互換性が不要なら，オートボクシングか <code>Double</code> ， <code>Float</code> の <code>valueOf</code> メソッドを使用してください。\n</p>",
	"DM_CONVERT_CASE":                                          "呼び出したメソッドの Locale パラメータの使用を検討する\n\n<p>\n文字列がプラットフォームのデフォルトエンコーディングを使用して大文字，小文字に変換されています。\n国際文字で使われると不適切な変換になることがあります。\n</p>\n<ul>\n  <li>String.toUpperCase(Locale l)</li>\n  <li>String.toLowerCase(Locale l)</li>\n</ul>",
	"BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR":              "プリミティブ値が3項演算子のためにアンボクシングされて，型変換される\n\n<p>\nラップされたプリミティブ値は，3項演算子 (<code>b ? e1 : e2</code>) の評価の一部として，別のプリミティブ型にアンボクシングされて変換されます。\nJava 言語仕様では， <code>e1</code> と <code>e2</code> がラップされた数値なら値はアンボクシングされ，共通の型へと変換/型変換されます\n(たとえば， <code>e1</code> が <code>Integer</code> で， <code>e2</code> が <code>Float</code> なら <code>e1</code> はアンボクシング (<code>int</code> に変換) され， <code>float</code> に変換され，ボクシング (<code>Float</code> に変換) されます)。\nJLS セクション15.25を参照してください。\n</p>",
	"BX_BOXING_IMMEDIATELY_UNBOXED":                            "プリミティブ値がボクシングされて，すぐにアンボクシングされる\n\n<p>\nプリミティブ値がボクシングされて，すぐにアンボクシングされます。\nおそらくアンボクシングされた値が必要な場所で手動でボクシングをしているためです。\nその結果，コンパイラにボクシングの機能を取り消すことを強制しています。\n</p>",
	"BX_UNBOXING_IMMEDIATELY_REBOXED":                          "ボクシングされた値がアンボクシングされて，すぐに再ボクシングされる\n\n<p>\nボクシングされた値がアンボクシングされて，すぐに再ボクシングされます。\n</p>",
	"BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION":        "プリミティブ値がプリミティブ型の型変換をするためにボクシングされて，アンボクシングされる\n\n<p>\nプリミティブ値がコンストラクタでボクシングされて，すぐに異なるプリミティブ型に変換されます (たとえば <code>new Double(d).intValue()</code>)。\n直接プリミティブ型の型変換を実行してください (たとえば <code>(int) d</code>)。\n</p>",
	"DM_BOXED_PRIMITIVE_TOSTRING":                              "toString メソッドを呼び出すためだけにボクシングされたプリミティブを割り当てている\n\n<p>\nボクシングされたプリミティブが <code>toString</code> メソッドを呼び出すためだけに割り当てられています。\nそれよりもプリミティブ値を引数にとる <code>static</code> な <code>toString</code> メソッドを使用したほうが効率的です。\n</p>\n<table>\n   <tr><th>置換前</th><th>置換後</th></tr>\n   <tr><td><code>new Integer(1).toString()</code></td>   <td><code>Integer.toString(1)</code></td></tr>\n   <tr><td><code>new Long(1).toString()</code></td>      <td><code>Long.toString(1)</code></td></tr>\n   <tr><td><code>new Float(1.0).toString()</code></td>   <td><code>Float.toString(1.0)</code></td></tr>\n   <tr><td><code>new Double(1.0).toString()</code></td>  <td><code>Double.toString(1.0)</code></td></tr>\n   <tr><td><code>new Byte(1).toString()</code></td>      <td><code>Byte.toString(1)</code></td></tr>\n   <tr><td><code>new Short(1).toString()</code></td>     <td><code>Short.toString(1)</code></td></tr>\n   <tr><td><code>new Boolean(true).toString()</code></td><td><code>Boolean.toString(true)</code></td></tr>\n</table>",
	"DM_BOXED_PRIMITIVE_FOR_PARSING":                           "プリミティブを解析するためのボクシング/アンボクシング\n\n<p>\nボクシングされたプリミティブがボクシングされていないプリミティブ値を抽出するために <code>String</code> から生成されています。\n<code>static parseXXX</code> メソッドを呼び出す方が効率的です。\n</p>",
	"DM_BOXED_PRIMITIVE_FOR_COMPARE":                           "プリミティブが比較でボクシングされている\n\n<p>\nボクシングされたプリミティブが単に <code>compareTo</code> メソッドを呼び出すために作られています。\n直接プリミティブで働く <code>static compare</code> メソッド (<code>double</code> と <code>float</code> は Java 1.4から，他のプリミティブ型は Java 1.7から) を使うほうがより効率的です。\n</p>",
	"DM_NEW_FOR_GETCLASS":                                      "クラスオブジェクトを得るためだけにインスタンスを作成しているメソッド\n\n<p>\nメソッドは，クラスオブジェクトを得るためにインスタンスを生成して <code>getClass</code> メソッドを呼び出しています。\nクラスリテラル (<code>Foo.class</code>) を使うほうが簡単です。\n</p>",
	"DM_MONITOR_WAIT_ON_CONDITION":                             "Condition で呼び出された wait メソッドを監視している\n\n<p>\nこのメソッドは， <code>java.util.concurrent.locks.Condition</code> オブジェクトで <code>wait</code> メソッドを呼び出しています。\n<code>Condition</code> オブジェクトを待機させるためには <code>Condition</code> インタフェースで定義された <code>await</code> メソッドを使用すべきです。\n</p>",
	"RV_01_TO_INT":                                             "0から1の乱数値は整数値0に丸められる\n\n<p>\n0から1の乱数値は整数値0に丸められます。\nおそらく整数に丸められる前に何か他のことによって乱数値を乗算したかったか，または <code>Random.nextInt(n)</code> メソッドを使いたかったのでしょう。\n</p>",
	"DM_INVALID_MIN_MAX":                                       "Math.max と Math.min の間違った組み合わせ\n\n<p>\nこのコードは <code>Math.min(0, Math.max(100, value))</code> のような構文を使用して境界値を制限しようとしています。\nしかしながら，定数の順序が間違っています。 <code>Math.min(100, Math.max(0, value))</code> とすべきです。\n結果としてこのコードは常に同じ結果 （もし値が <code>NaN</code> なら <code>NaN</code>） を作り出します。\n</p>",
	"DM_NEXTINT_VIA_NEXTDOUBLE":                                "整数の乱数を生成するためには nextDouble メソッド ではなく nextInt メソッドを使用する\n\n<p>\n<code>java.util.Random</code> のインスタンス <code>r</code> で， <code>0</code> から <code>n-1</code> の乱数を生成したいのであれば， <code>(int)(r.nextDouble() * n)</code> ではなく <code>r.nextInt(n)</code> を使用します。\n</p>\n<p>\n<code>nextInt</code> メソッドへの引数は整数でなければなりません。\nたとえば，-99から0までの乱数を生成したいなら， <code>-r.nextInt(100)</code> を使用してください。\n</p>",
	"SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE":                 "SQL の Statement の execute または addBatch メソッドに定数ではない文字列を渡している\n\n<p>\nこのメソッドは，動的に生成されるように思われる文字列で，SQL 文 の <code>execute</code> または <code>addBatch</code> メソッドを呼び出しています。\nその代わりに <code>PreparedStatement</code> を使用することを検討してください。\n効率的で，SQL インジェクション攻撃に強いです。\n</p>",
	"SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING": "PreparedStatement が定数ではない文字列から生成されている\n\n<p>\nこのコードは定数ではない文字列から SQL の <code>PreparedStatement</code> を作成しています。\nユーザからのチェックされていない汚染されたデータがこの文字列を作る際に使われるなら， <code>PreparedStatement</code> で予想外で望ましくない何かをするために SQL インジェクションが使われる可能性があります。\n</p>",
	"DM_USELESS_THREAD":                                        "デフォルトの空の run メソッドを使用して作成されたスレッド\n\n<p>\nこのメソッドは， <code>Thread</code> クラスから派生した <code>run</code> メソッドを指定していないか， <code>Runnable</code> オブジェクトを渡すことなく，スレッドを作成しています。\nこのスレッドは，時間の無駄です。\n</p>",
	"DC_DOUBLECHECK":                                           "フィールドのダブルチェックの可能性\n\n<p>\nこのメソッドにはダブルチェックロッキングのインスタンスがあるかもしれません。このイディオムは，Java のメモリモデルでは正しくありません。<br>\n詳細は， <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\" >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a> を参照してください。\n</p>",
	"DC_PARTIALLY_CONSTRUCTED":                                 "部分的に初期化されたオブジェクトを暴露する可能性がある\n\n<p>\nダブルチェックロッキングと共に遅延初期化フィールドを使用するメソッドのようです。\nフィールドが正しく <code>volatile</code> として宣言される間にオブジェクトの内部構造がフィールドに割り当てられた後で変更される可能性があります。\nしたがって，他のスレッドが部分的に初期化されたオブジェクトを見るかもしれません。\n</p>\n<p>\nこの問題を直すために，最初にローカル変数をオブジェクトに格納して，完全に構築した後で <code>volatile</code> フィールドを保存することを考えてください。\n</p>",
	"FI_FINALIZER_NULLS_FIELDS":                                "ファイナライザはフィールドを null にする\n\n<p>\nこのファイナライザは，フィールドを <code>null</code> にしています。\nこれは通常誤りでガベージコレクタを助けません。オブジェクトはいずれにしろガベージされます。\n</p>",
	"FI_FINALIZER_ONLY_NULLS_FIELDS":                           "ファイナライザはフィールドを null にするだけ\n\n<p>\nこのファイナライザは，フィールドを <code>null</code> にすること以外に何もしません。\nこれはまったく無意味であり，オブジェクトがガベージされ，ファイナライズされ，再びガベージされることを要求しています。\n<code>finalize</code> メソッドを除去すべきです。\n</p>",
	"FI_PUBLIC_SHOULD_BE_PROTECTED":                            "ファイナライザは public ではなく protected にすべき\n\n<p>\nこのクラスの <code>finalize</code> メソッドは <code>public</code> ではなく， <code>protected</code> にすべきです。\n</p>",
	"FI_EMPTY":                                                 "空のファイナライザは削除すべき\n\n<p>\n空の <code>finalize</code> メソッドは役に立たないので削除すべきです。\n</p>",
	"FI_NULLIFY_SUPER":                                         "ファイナライザはスーパークラスのファイナライザを無効にしている\n\n<p>\nこの空の <code>finalize</code> メソッドは，明示的にスーパークラスによって定義されたどんなファイナライザの効果も無効にします。\nスーパークラスのために定義されたどんなファイナライザアクションも実行されません。\nこれが意図したことではない場合，メソッドを削除してください。\n</p>",
	"FI_USELESS":                                               "ファイナライザはスーパークラスのファイナライザを呼び出しているだけ\n\n<p>\nこの <code>finalize</code> メソッドは，スーパークラスの <code>finalize</code> メソッドを呼び出しているだけです。\n冗長なので削除してください。\n</p>",
	"FI_MISSING_SUPER_CALL":                                    "ファイナライザはスーパークラスのファイナライザを呼び出していない\n\n<p>\nこの <code>finalize</code> メソッドは，スーパークラスの <code>finalize</code> メソッドを呼び出していません。\nしたがって，スーパークラスのために定義されたどんなファイナライザアクションも実行されません。\n<code>super.finalize()</code> の呼び出しを追加してください。\n</p>",
	"FI_EXPLICIT_INVOCATION":                                   "ファイナライザの明示的な呼び出し\n\n<p>\nこのメソッドには明示的にオブジェクトで <code>finalize</code> メソッドの呼び出しがあります。\nファイナライザは Java 仮想マシンによって1度だけ実行されることになっているので，これは間違った考えです。\n</p>\n<p>\n参照によってつながった複数のオブジェクトがファイナライズ可能になると，Java 仮想マシンはすべてのオブジェクトの <code>finalize</code> メソッドを呼び出します。\nおそらく異なるスレッドで同時にです。\nしたがって，クラス <i>X</i> の <code>finalize</code> メソッドの中から <i>X</i> によって参照されているオブジェクトの <code>finalize</code> メソッドを呼び出すのは，とりわけ間違った考えです。\nなぜなら，オブジェクトが既に別のスレッドによってファイナライズされているかもしれないからです。\n</p>",
	"EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS":            "equals メソッドは互換性のないオペランドをチェックしている\n\n<p>\nこの <code>equals</code> メソッドは，引数が互換性のない型 (すなわちスーパタイプでもなく， <code>equals</code> メソッドを定義しているクラスのスーパータイプでもサブタイプでもないクラス) なのか確かめています。\nたとえば， <code>Foo</code> クラスの <code>equals</code> メソッドはそのように見えるかもしれません。\n</p>\n<pre><code>public boolean equals(Object o) {\n    if (o instanceof Foo)\n        return name.equals(((Foo)o).name);\n    else if (o instanceof String)\n        return name.equals(o);\n    else return false;\n}\n</code></pre>\n<p>\nこれは対称的で推移的である <code>equals</code> メソッドを実現するのはとても難しいので，バッドプラクティスと見なされています。\nプロパティがなければまったく予想していない振る舞いが起こりえます。\n</p>",
	"EQ_DONT_DEFINE_EQUALS_FOR_ENUM":                           "列挙型は共変な equals メソッドを定義している\n\n<p>\nこのクラスは列挙を定義していて，列挙の等価性はオブジェクト同一性を使用して定義されています。\n列挙値のために共変な <code>equals</code> メソッドを定義することは，ひどいバッドプラクティスです。\n2つの異なる列挙値が <code>equals</code> メソッドでは「等価ではない」と判定され，共変な <code>equals</code> メソッドでは「等価」と判定されるからです。\n共変な <code>equals</code> メソッドを定義しないでください。\n</p>",
	"EQ_SELF_USE_OBJECT":                                       "共変な equals メソッドを定義して，Object.equals(Object) を継承している\n\n<p>\nこのクラスは，共変な <code>equals</code> メソッドを定義していますが， <code>equals(Object)</code> メソッドは <code>java.lang.Object</code> クラスから継承しています。\nクラスは， <code>boolean equals(Object)</code> メソッドを定義すべきです。\n</p>",
	"EQ_OTHER_USE_OBJECT":                                      "Object.equals(Object) をオーバーライドしていない equals メソッドの定義\n\n<p>\nこのクラスは， <code>equals</code> メソッドを定義していますが， <code>java.lang.Object</code> クラスの <code>equals(Object)</code> メソッドをオーバーライドしていません。\nクラスは， <code>boolean equals(Object)</code> メソッドを定義すべきです。\n</p>",
	"EQ_OTHER_NO_OBJECT":                                       "equals(Object) メソッドをオーバーライドしていない equals メソッドの定義\n\n<p>\nこのクラスは， <code>equals</code> メソッドを定義していますが， <code>java.lang.Object</code> クラスの <code>equals(Object)</code> メソッドをオーバーライドしていません。\nその代わりに，スーパークラスから <code>equals(Object)</code> メソッドを継承して， <code>boolean equals(Object)</code> メソッドを定義すべきです。\n</p>",
	"EQ_DOESNT_OVERRIDE_EQUALS":                                "スーパークラスの equals メソッドをオーバーライドしていないクラス\n\n<p>\nこのクラスは， <code>equals</code> メソッドを定義しているクラスを拡張してフィールドを追加していますが， <code>equals</code> メソッドを定義していません。\nしたがって，このクラスのインスタンスの等価性は，サブクラスと追加されたフィールドの同一性を無視します。\nこれが意図したことで，しかも， <code>equals</code> メソッドをオーバーライドする必要がないことを確実にしてください。\nたとえ <code>equals</code> メソッドをオーバーライドする必要がないとしても，サブクラスのための <code>equals</code> メソッドが <code>super.equals(o)</code> を呼び出して結果を返すという事実を実証するためにいずれにしろ， <code>equals</code> メソッドをオーバーライドすることを検討してください。\n</p>",
	"EQ_SELF_NO_OBJECT":                                        "共変な equals メソッドの定義\n\n<p>\nこのクラスは，共変な <code>equals</code> メソッドを定義しています。\n<code>java.lang.Object</code> の <code>equals</code> メソッドを正しくオーバーライドするためには <code>equals</code> メソッドのパラメータの型は， <code>java.lang.Object</code> でなければなりません。\n</p>",
	"EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC":                       "equals メソッドはスーパークラスの equals メソッドをオーバーライドしているが，対称的ではないかもしれない\n\n<p>\nこのクラスはスーパークラスの <code>equals</code> メソッドをオーバーライドする <code>equals</code> メソッドを定義しています。\n両方の <code>equals</code> メソッドは，2つのオブジェクトが等しいかどうかの判定で， <code>instanceof</code> を使用しています。\n<code>equals</code> メソッドは対称的 (<code>a.equals(b) == b.equals(a)</code>) であることが重要なのでこれは危険を伴っています。\n<i>B</i> が <i>A</i> のサブタイプなら <i>A</i> の <code>equals</code> メソッドは引数が <code>instanceof A</code> なのかチェックします。\nそして， <i>B</i> の <code>equals</code> メソッドは引数が <code>instanceof B</code> なのかチェックします。\nこれらのメソッドによって定義された同値関係が対称的ではないということです。\n</p>",
	"EQ_GETCLASS_AND_CLASS_CONSTANT":                           "equals メソッドはサブタイプのために失敗する\n\n<p>\nこのクラスは，サブクラスによる継承によって壊れる <code>equlas</code> メソッドがあります。\n<code>equals</code> メソッドは，クラスリテラルを引数のクラスと比較しています (たとえば， <code>Foo</code> クラスで <code>Foo.class == o.getClass()</code> のような判定を行っています)。\n<code>this.getClass() == o.getClass()</code> の方がより良いです。\n</p>",
	"EQ_UNUSUAL":                                               "異常な equals メソッド \n\n<p>\nこのクラスの <code>equals</code> メソッドは，引数の型が <code>this</code> オブジェクトの型と互換性があるこをチェックするために我々が認識しているパターンで何もしていません。\nこのコードは何も間違っていないかもしれませんが，レビューする価値があります。\n</p>",
	"EQ_COMPARING_CLASS_NAMES":                                 "equals メソッドはクラスオブジェクトではなくクラス名を比較している\n\n<p>\nこのメソッドは，クラス名を比較することによって，2つのオブジェクトが同じクラスなのか確かめています。\n異なるクラスローダによってロードされたクラスなら，同じ名前で異なるクラスがある可能性があります。\nクラスオブジェクトが同じなのか確かめてください。\n</p>",
	"EQ_ALWAYS_TRUE":                                           "equals メソッドは常に true を返す\n\n<p>\nこのクラスは，常に <code>true</code> を返す <code>equals</code> メソッドを定義しています。\nこれは想像力に富むが，あまり良い方法とはいえません。さらに， <code>equals</code> メソッドが対称的ではないことを意味します。\n</p>",
	"EQ_ALWAYS_FALSE":                                          "equals メソッドは常に false を返す\n\n<p>\nこのクラスでは，常に <code>false</code> を返す <code>equlas</code> メソッドを定義しています。\nこれはオブジェクトがそれ自身と等価ではないことを意味していて，このクラスの有用な <code>Map</code> や <code>Set</code> を作成できません。\nより根本的に， <code>equals</code> メソッドの要件の一つである反射性を満たしていないことになります。\n</p>\n<p>\nおそらく意図されたことは，オブジェクトはそれ自身と等価であるというオブジェクト同一性です。\nこれは <code>Object</code> クラスから継承される振る舞いです。\n異なるスーパークラスから継承される <code>equals</code> メソッドをオーバーライドする必要があるなら次のようなコードが使えます。\n</p>\n<pre><code>public boolean equals(Object o) {\n    return this == o;\n}\n</code></pre>",
	"HSC_HUGE_SHARED_STRING_CONSTANT":                          "複数のクラスファイルにわたって複製されている巨大な文字列定数\n\n<p>\n巨大な文字列定数が複数のクラスファイルにわたって複製されています。\n<code>final</code> フィールドが文字列定数で初期化され，Java 言語によって他のクラスからの <code>final</code> フィールドへのすべての参照がクラスファイルにインライン化されるからです。\n</p>\n<p>\nJDK はこのバグを解決してサイズを1MB減らすことができました。<br>\n詳細は， <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475\">JDK bug 6447475</a> を参照してください。\n</p>",
	"NP_ARGUMENT_MIGHT_BE_NULL":                                "null の引数をチェックしていないメソッド\n\n<p>\nこのメソッドへのパラメータが <code>null</code> かどうか確かめるために常にチェックされるべき値として特定されました。\nしかし， <code>null</code> チェックをしないで， <code>null</code> 値が利用されています。\n</p>",
	"NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT":                    "equals メソッドは null の引数をチェックしていない\n\n<p>\nこの <code>equals(Object)</code> メソッドの実装は引数として渡されている <code>null</code> をチェックしていないので， <code>java.lang.Object.equals()</code> で定義された規約に違反しています。\nすべての <code>equals</code> メソッドは引数に <code>null</code> が渡されたなら <code>false</code> を返すべきです。\n</p>",
	"RV_NEGATING_RESULT_OF_COMPARETO":                          "compareTo()/compare() の結果を無効にする\n\n<p>\nこのコードは <code>compareTo</code> または <code>compare</code> メソッドの戻り値を無効にしています。\nこれは疑わしいかバッドプログラミングプラクティスです。戻り値が <code>Integer.MIN_VALUE</code> なので，戻り値を無効にすることは結果の符号を無効にしません。\n結果を無効にするのではなくオペランドの順序を逆にすることによって，同じ意図した結果を得ることができます。\n</p>",
	"CO_COMPARETO_RESULTS_MIN_VALUE":                           "compareTo()/compare() は Integer.MIN_VALUE を返す\n\n<p>\nいくつかの状況下では，この <code>compareTo</code> または <code>compare</code> メソッドは <code>Integer.MIN_VALUE</code> を返します。非常に悪いプラクティスです。\n<code>compareTo</code> メソッドの戻り値で重要なことは結果の符号だけです。\nしかし，結果の符号を無効にすることを期待して， <code>compareTo</code> メソッドの戻り値を無効にすることがあります。\n返された値が <code>Integer.MIN_VALUE</code> の場合を除いてです。 <code>Integer.MIN_VALUE</code> よりも-1を返してください。\n</p>",
	"CO_COMPARETO_INCORRECT_FLOATING":                          "compareTo()/compare() は間違って float または double 値を処理する\n\n<p>\nこのメソッドはこのようなパターンを使用して <code>double</code> または <code>float</code> 値を比較しています ： <code>val1 &gt; val2 ? 1 : val1 &lt; val2 ? -1 : 0</code>。\nこのパターンは，-0.0 や <code>NaN</code> の値が正しく処理されたないため，不正なソート結果や破損したコレクション（比較された値がキーとして使われる場合）が生成される可能性があります。\n<code>Double.compare</code> または <code>Float.compare</code> メソッドを使用して，すべての特殊なケースを正確に処理することを検討してください。\n</p>",
	"CO_SELF_NO_OBJECT":                                        "共変な compareTo メソッドの定義\n\n<p>\nこのクラスは，共変な <code>compareTo</code> メソッドを定義しています。\n<code>Comparable</code> インタフェースの <code>compareTo</code> メソッドを正しく実装するためには <code>compareTo</code> メソッドのパラメータの型は， <code>java.lang.Object</code> でなければなりません。\n</p>",
	"HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS":        "ハッシュ化されたコンテキストでハッシュ化できないクラスの使用がシグネチャで宣言されている\n\n<p>\nメソッド，フィールド，クラスは，ハッシュ可能なクラスが必要なコンテキストで，ハッシュ化できないクラスが使用される総称的なシグネチャを宣言しています。\nクラスは， <code>equals</code> メソッドを宣言していますが， <code>hashCode</code> メソッドは <code>java.lang.Object</code> から継承しています。\nこれは「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に従っていないのでハッシュ化できません。\n</p>",
	"HE_USE_OF_UNHASHABLE_CLASS":                               "ハッシュデータ構造で hashCode メソッドのないクラスを使用している\n\n<p>\nこのクラスは， <code>equals(Object)</code> メソッドを定義していますが， <code>hashCode</code> メソッドを定義していません。\nこれは「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に従っていません。\nこのクラスのインスタンスはハッシュデータ構造で使われています。最重要問題を修正する必要があります。\n</p>",
	"HE_HASHCODE_USE_OBJECT_EQUALS":                            "hashCode メソッドを定義して Object.equals() を使用しているクラス\n\n<p>\nこのクラスは， <code>hashCode</code> メソッドを定義していますが， <code>equals</code> メソッドは <code>java.lang.Object</code> から継承しています (オブジェクトの参照比較で等価性を判定します)。\nこれは「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に従っているかもしれませんが，\nおそらく， <code>hashCode</code> メソッドをオーバーライドすることによって意図されたことではありません。\n(<code>hashCode</code> メソッドをオーバーライドすることは，オブジェクトの同一性が単純な参照等価性よりも複雑な規約に基づくことを意味します)。\n</p>\n<p>\nこのクラスのインスタンスが <code>HashMap</code>/<code>HashTable</code> に決して代入されるだろうと思わないなら推奨される <code>hashCode</code> メソッドの実装は次のようになります。\n</p>\n<pre><code>public int hashCode() {\n    assert false : \"hashCodeが呼び出されることは想定されていません。\";\n    return 42; // 任意の定数\n}\n</code></pre>",
	"EQ_COMPARETO_USE_OBJECT_EQUALS":                           "compareTo(...) メソッドを定義して Object.equals() を使用しているクラス\n\n<p>\nこのクラスは， <code>compareTo(...)</code> メソッドを定義していますが， <code>equals</code> メソッドは <code>java.lang.Object</code> から継承しています。\n一般的に<code>equals</code> メソッドが <code>true</code> を返す場合に限り， <code>compareTo</code> メソッドは0を返すべきです。\nこれが違反されるなら奇妙で予測できない失敗が <code>PriorityQueue</code> などのクラスで発生します。\nJ2SE 5.0では， <code>PriorityQueue.remove()</code> は <code>compareTo</code> メソッドを使用しますが，Java SE 6では， <code>equals</code> メソッドを使用します。\n</p>\n<p>\n<code>Comparable</code> インタフェースの <code>compareTo</code> メソッドの JavaDoc を引用します。\n</p>\n<blockquote><p>\n必須というわけではありませんが， <code>(x.compareTo(y)==0) == (x.equals(y))</code> であることが強く推奨されます。\n一般的に<code>Comparable</code> インタフェースを実装しているクラスで，この条件に違反するクラスは明確にこの事実を示す必要があります。\n「注:このクラスは <code>equals</code> と一貫性のない自然順序付けを持ちます」などと明示することをお勧めします。\n</p></blockquote>",
	"HE_HASHCODE_NO_EQUALS":                                    "hashCode メソッドを定義していますが equals メソッドは定義していないクラス\n\n<p>\nこのクラスは， <code>hashCode</code> メソッドを定義していますが， <code>equals</code> メソッドは定義していません。\nこれは「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に違反するかもしれません。\n</p>",
	"HE_EQUALS_USE_HASHCODE":                                   "equals メソッドを定義して Object.hashCode() を使用しているクラス\n\n<p>\nこのクラスは， <code>equals(Object)</code> をオーバーライドしていますが， <code>hashCode</code> メソッドは <code>java.lang.Object</code> から継承しています (同一性ハッシュコード (Java 仮想マシンによってオブジェクトに代入された任意の値) を返します)。\nしたがって，「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に違反するかもしれません。\n</p>\n<p>\nこのクラスのインスタンスが <code>HashMap</code>/<code>HashTable</code> に決して代入されるだろうと思わないなら推奨される <code>hashCode</code> メソッドの実装は次のようになります。\n</p>\n<pre><code>public int hashCode() {\n    assert false : \"hashCodeが呼び出されることは想定されていません。\";\n    return 42; // 任意の定数\n}\n</code></pre>",
	"HE_INHERITS_EQUALS_USE_HASHCODE":                          "equals メソッドを継承して Object.hashCode() を使用しているクラス\n\n<p>\nこのクラスは，抽象スーパークラスから <code>equals(Object)</code> メソッドを継承して， <code>java.lang.Object</code> から <code>hashCode</code> メソッドを継承しています (同一性ハッシュコード (Java 仮想マシンによってオブジェクトに代入された任意の値) を返します)。\nしたがって，「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に違反するかもしれません。\n</p>\n<p>\n<code>hashCode</code> メソッドを定義したくないまたはオブジェクトが <code>HashMap</code>/<code>Hashtable</code> に決して格納されないだろうと思っているなら <code>UnsupportedOperationException</code> をスローする <code>hashCode()</code> メソッドを定義してください。\n</p>",
	"HE_EQUALS_NO_HASHCODE":                                    "equals メソッドは定義していますが hashCode メソッドは定義していないクラス\n\n<p>\nこのクラスは， <code>equals(Object)</code> メソッドをオーバーライドしていますが， <code>hashCode</code> メソッドはオーバーライドしていません。\nしたがって，「等価なオブジェクトは等価なハッシュコードを保持する必要がある」という <code>hashCode</code> メソッドの汎用規約に違反するかもしれません。\n</p>",
	"EQ_ABSTRACT_SELF":                                         "抽象クラスは共変な equals メソッドを宣言している\n\n<p>\nこのクラスは，共変な <code>equals</code> メソッドを定義しています。\n<code>java.lang.Object</code> の <code>equals</code> メソッドを正しくオーバーライドするためには <code>equals</code> メソッドのパラメータの型は， <code>java.lang.Object</code> でなければなりません。\n</p>",
	"ES_COMPARING_STRINGS_WITH_EQ":                             "String オブジェクトを == や != を使用して比較している\n\n<p>\nこのコードは参照等価性のために <code>==</code> や <code>!=</code> を使用して <code>java.lang.String</code> オブジェクトを比較しています。\n両方の文字列がソースファイルの定数か， <code>String.intern()</code> を使用して正準化されていないかぎり，同じ文字列は2つの異なる <code>String</code> オブジェクトによって表されるかもしれません。\nその代わりに <code>equals(Object)</code> メソッドを使用することを検討してください。\n</p>",
	"ES_COMPARING_PARAMETER_STRING_WITH_EQ":                    "String パラメータを == や != を使用して比較している\n\n<p>\nこのコードは参照等価性のために <code>==</code> や <code>!=</code> を使用して <code>java.lang.String</code> パラメータを比較しています。\n文字列定数または正準化された文字列だけをメソッドに渡すことを呼び出し元に要求することは，不必要に脆弱であり，測定可能な性能の向上につながることはほとんどありません。\nその代わりに <code>equals(Object)</code> メソッドを使用することを検討してください。\n</p>",
	"CO_ABSTRACT_SELF":                                         "抽象クラスは共変な compareTo メソッドを定義している\n\n<p>\nこのクラスは，共変な <code>compareTo</code> メソッドを定義しています。\n<code>Comparable</code> インタフェースの <code>compareTo</code> メソッドを正しく実装するためには <code>compareTo</code> メソッドのパラメータの型は， <code>java.lang.Object</code> でなければなりません。\n</p>",
	"IS_FIELD_NOT_GUARDED":                                     "並行アクセスに対してガードされていないフィールド\n\n<p>\nこのフィールドは， <code>net.jcip.annotations.GuardedBy</code> または <code>javax.annotation.concurrent.GuardedBy</code> というアノテーションが付けられていますが，アノテーションに違反するような方法でアクセスできます。\n</p>",
	"MSF_MUTABLE_SERVLET_FIELD":                                "可変サーブレットフィールド\n\n<p>\nWeb サーバは，一般的にサーブレットや JSP クラスのインスタンスを1つだけ作成します (すなわち，シングルトンとして扱います)。\n複数のスレッドが複数同時のリクエストに応えるためにそのインスタンスでメソッドを呼び出します。\nしたがって，一般に可変インスタンスフィールドは競合状態を作ります。\n</p>",
	"IS2_INCONSISTENT_SYNC":                                    "一貫性のない同期化\n\n<p>\nこのクラスのフィールドは，同期化に関して一貫性なくアクセスされるように見えます。\nこのバグレポートは，バグパターンディテクタが次のように判断したことを示します。\n</p>\n<ul>\n  <li>クラスは，ロックされたアクセスとアンロックされたアクセスが混在していて， </li>\n  <li>クラスは， <code>javax.annotation.concurrent.NotThreadSafe</code> アノテーションが付けられていなくて， </li>\n  <li>少なくとも1つのロックされたアクセスがクラス自身のメソッドの1つによって実行され， </li>\n  <li>読み出しの2倍の重み付けをした書き込みで，非同期フィールドのアクセス (読み出しと書き込み) 数がすべてのアクセスのわずか1/3</li>\n</ul>\n<p>\nこのバグパターンに合致する一般的なバグは，スレッドセーフを意図したクラスでメソッドを同期化させることを忘れていることです。\n</p>\n<p>\n「非同期アクセス」というラベルがついているノードを選択すると，ディテクタが同期化しないでフィールドにアクセスしたと信じているコードの場所を表示できます。\n</p>\n<p>\n不正確ないろいろな原因がこのディテクタにあることに注意してください。\nたとえば，ディテクタはロックを保持されるすべての状況を静的に検出できるわけではありません。\nまた，ディテクタがロックされたアクセスとアンロックされたアクセスの区別が正確なときでも，問題のコードは依然として正しいかもしれません。\n</p>",
	"NN_NAKED_NOTIFY":                                          "裸の notify メソッド\n\n<p>\n<code>notify</code> メソッドまたは <code>notifyAll</code> メソッドへの呼び出しは可変オブジェクト状態にどんな (明らかな) 付随的な変更ももたらされませんでした。\n一般的に別のスレッドが期待しているいくつかの条件が真になったので，モニタで <code>notify</code> メソッドが呼び出されます。\nしかしながら，意味がある条件のために両方のスレッドに見えるヒープオブジェクトを含まなければなりません。\n</p>\n<p>\n可変オブジェクトの状態変更が通知があるメソッドを呼び出したメソッドで起こったかもしれないので，このバグが必ずしもエラーを示すというわけではありません。\n</p>",
	"MS_EXPOSE_REP":                                            "配列を返すことによって内部表現を暴露するかもしれない public static メソッド\n\n<p>\n<code>public static</code> メソッドは，クラスの 静的な状態の一部である配列の参照を返します。\nこのメソッドを呼び出すどんなコードも，基底配列を自由に変更できます。\n解決策は，配列のコピーを返すことです。\n</p>",
	"EI_EXPOSE_REP":                                            "可変オブジェクトへの参照を返すことによって内部表現を暴露するかもしれないメソッド\n\n<p>\nオブジェクトのフィールドに格納された可変オブジェクトの参照を返すと，オブジェクトの内部表現を暴露します。\nインスタンスが信頼できないコードによってアクセスされるなら，可変オブジェクトのチェックされていない変更がセキュリティや他の重要なプロパティを危うくするでしょう。\n何か違うことをする必要があります。オブジェクトの新しいコピーを返すことは，多くの状況でより良いアプローチです。\n</p>",
	"EI_EXPOSE_REP2":                                           "可変オブジェクトへの参照を取り込むことによって内部表現を暴露するかもしれないメソッド\n\n<p>\nこのコードはオブジェクトの内部表現に外部の可変オブジェクトの参照を格納しています。\nインスタンスが信頼できないコードによってアクセスされるなら，可変オブジェクトのチェックされていない変更がセキュリティや他の重要なプロパティを危うくするでしょう。\n何か違うことをする必要があります。オブジェクトのコピーを格納することは，多くの状況でより良いアプローチです。\n</p>",
	"EI_EXPOSE_STATIC_REP2":                                    "static フィールドに可変オブジェクトを格納することによって，内部の静的状態を暴露するかもしれないメソッド\n\n<p>\nこのコードは <code>static</code> フィールドに外部の可変オブジェクトを格納しています。\n可変オブジェクトのチェックされていない変更がセキュリティや他の重要なプロパティを危うくするでしょう。\n何か違うことをする必要があります。オブジェクトのコピーを格納することは，多くの状況でより良いアプローチです。\n</p>",
	"RU_INVOKE_RUN":                                            "スレッドで run メソッドを呼び出している\n\n<p>\nこのメソッドは，スレッドで 明示的に <code>run</code> メソッドを呼び出しています。\n一般的にクラスは新しいスレッドで自己の <code>run</code> メソッドを呼び出してもらうために <code>Runnable</code> インタフェースを実装します。\nその場合は， <code>Thread.start()</code> を呼び出すのが正しいです。\n</p>",
	"SP_SPIN_ON_FIELD":                                         "スピンロックをしているメソッド\n\n<p>\nこのメソッドは，フィールドを読み出すループで回り続けます。\nコンパイラがフィールドの読み出しをループの外に出すかもしれません。コードを無限ループに変えます。\n正しい同期化 (<code>wait</code>/<code>notify</code> を呼び出すように含む) を使うようにクラスを変更すべきです。\n</p>",
	"NS_DANGEROUS_NON_SHORT_CIRCUIT":                           "潜在的な非短絡論理の危険な使用\n\n<p>\nこのコードは短絡論理 (<code>&amp;&amp;</code> や <code>||</code>) ではなく非短絡論理 (<code>&amp;</code> や <code>|</code>) を使用していると思われます。\nさらに，左辺値によって右辺を評価したくない (例外のスローや演算が高くつく副作用があるため) と思っているのかもしれません。\n非短絡論理は，左辺を知ることによって結果を推論できたとしても両側の式が評価されます。\nこれは効率が悪く，右辺の評価でエラーが発生するケースを左辺でガードしているなら，結果としてエラーになる可能性があります。\n</p>\n<p>\n詳細については， <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2\">The Java Language Specification</a> を参照してください。\n</p>",
	"NS_NON_SHORT_CIRCUIT":                                     "非短絡論理の疑わしい使用\n\n<p>\nこのコードは短絡論理 (<code>&amp;&amp;</code> や <code>||</code>) ではなく非短絡論理 (<code>&amp;</code> や <code>|</code>) を使用していると思われます。\n非短絡論理は，左辺を知ることによって結果を推論できたとしても両側の式が評価されます。\nこれは効率が悪く，右辺の評価でエラーが発生するケースを左辺でガードしているなら，結果としてエラーになる可能性があります。\n</p>\n<p>\n詳細については， <a href=\"https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.22.2\">The Java Language Specification</a> を参照してください。\n</p>",
	"TLW_TWO_LOCK_WAIT":                                        "2つ以上のロックを保持して wait メソッドを呼び出している\n\n<p>\n2つ以上のロックを保持して，モニタで待機させるとデッドロックを引き起こすことがあります。\n<code>wait</code> メソッドを呼び出すと，待機しているオブジェクトのロックを解除するだけで，その他のロックは解除しません。\nこれは必ずしもバグではありませんが厳密に調べる価値があります。\n</p>",
	"TLW_TWO_LOCK_NOTIFY":                                      "Notify with two locks held\n\n<p> The code calls notify() or notifyAll() while two locks\n  are held. If this notification is intended to wake up a wait()\n  that is holding the same locks, it may deadlock, since the wait\n  will only give up one lock and the notify will be unable to get both locks,\n  and thus the notify will not succeed.\n   &nbsp; If there is also a warning about a two lock wait, the\n   probably of a bug is quite high.\n</p>",
	"UW_UNCOND_WAIT":                                           "wait メソッドの無条件呼び出し\n\n<p>\nこのメソッドには条件制御フローによってガードされない <code>java.lang.Object.wait()</code> の呼び出しがあります。\nこのコードは <code>wait</code> メソッドを呼び出す前に待機するつもりだった条件が既に満たされていないことを確かめるべきです。\nどんな前の通知も無視されます。\n</p>",
	"UR_UNINIT_READ":                                           "コンストラクタで初期化されていないフィールドを読み出している\n\n<p>\nこのコンストラクタは，まだ値が代入されていないフィールドを読み出しています。\n多くの場合，プログラマがコンストラクタのパラメータの代わりに誤ってフィールドを使うときに起きます。\n</p>",
	"UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR":             "スーパークラスのコンストラクタから呼び出されるメソッドで初期化されていないフィールドを読み出している\n\n<p>\nこのメソッドは，スーパークラスのコンストラクタで呼びされています。この時点では，クラスのフィールドはまだ初期化されていません。\n</p>\n<p>\nこれはたくさんの具象クラスを作るためです。次のクラスを検討してください。\n</p>\n<pre><code>abstract class A {\n    int hashCode;\n    abstract Object getValue();\n\n    A() {\n        hashCode = getValue().hashCode();\n    }\n}\n\nclass B extends A {\n    Object value;\n\n    B(Object v) {\n        this.value = v;\n    }\n\n    Object getValue() {\n        return value;\n    }\n}\n</code></pre>\n<p>\n<code>B</code> が構築されるとき， <code>B</code> のコンストラクタが <code>value</code> に値を設定する前に， <code>A</code> クラスのコンストラクタが呼び出されます。\nしたがって， <code>A</code> のコンストラクタが <code>getValue</code> を呼び出すとき， <code>value</code> の初期化されていない値が読み出されます。\n</p>",
	"UG_SYNC_SET_UNSYNC_GET":                                   "同期化していない get メソッド，同期化している set メソッド\n\n<p>\nこのクラスには類似した名前の get メソッドと set メソッドがあり，set メソッドは同期化していて，get メソッドは同期化していません。\nget メソッドの呼び出し元がオブジェクトの一貫した状態を必ずしも見るというわけではないので，実行時に間違った振る舞いの原因になることがあります。\nget メソッドは同期化すべきです。\n</p>",
	"IC_INIT_CIRCULARITY":                                      "初期化が循環している\n\n<p>\nバグインスタンスによって参照される2つのクラスのスタティックイニシャライザで循環が検出されました。\nさまざまな予想外の振る舞いはそのような循環に起因することがあります。\n</p>",
	"IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION":        "スーパークラスは初期化中にサブクラスを使用している\n\n<p>\nクラスは，初期化中にサブクラスを積極的に使用しています。サブクラスはこの時点ではまだ初期化されていません。<br>\nたとえば，次のコードにおいて， <code>foo</code> は <code>null</code> です。\n</p>\n<pre><code>public class CircularClassInitialization {\n    static class InnerClassSingleton extends CircularClassInitialization {\n        static InnerClassSingleton singleton = new InnerClassSingleton();\n    }\n\n    static CircularClassInitialization foo = InnerClassSingleton.singleton;\n}\n</code></pre>",
	"IT_NO_SUCH_ELEMENT":                                       "Iterator.next() が NoSuchElementException をスローできない\n\n<p>\nこのクラスは， <code>java.util.Iterator</code> を実装しています。\nしかしながら， <code>next</code> メソッドは <code>java.util.NoSuchElementException</code> をスローできません。\n<code>next</code> メソッドは，それ以上要素を返すことができないときは <code>NoSuchElementException</code> をスローするように変更すべきです。\n</p>",
	"DL_SYNCHRONIZATION_ON_SHARED_CONSTANT":                    "正準化した文字列の同期化\n\n<p>\nこのコードは正準化した文字列で同期化しています。\n</p>\n<pre><code>private static String LOCK = \"LOCK\";\n...\nsynchronized(LOCK) {\n    ...\n}\n...\n</code></pre>\n<p>\n文字列定数は正準化され，Java 仮想マシンによってロードされたすべてのクラス全体で共有されます。\nこのコードは，他のコードがロックしている可能性があるものをロックしています。\nこれはブロックとデッドロックの振る舞いを診断するのが非常に奇妙で困難になる可能性があります。<br>\n詳細は， <a href=\"http://www.javalobby.org/java/forums/t96352.html\">http://www.javalobby.org/java/forums/t96352.html</a> と <a href=\"http://jira.codehaus.org/browse/JETTY-352\">http://jira.codehaus.org/browse/JETTY-352</a> を参照してください。\n</p>\n<p>\nCERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\">CON08-J. Do not synchronize on objects that may be reused</a> を参照してください。\n</p>",
	"DL_SYNCHRONIZATION_ON_BOOLEAN":                            "Boolean の同期化\n\n<p>\n<code>Boolean</code> のようなボクシングされたプリミティブ型の定数で同期化しています。\n</p>\n<pre><code>private static Boolean inited = Boolean.FALSE;\n...\nsynchronized(inited) {\n    if (!inited) {\n        init();\n        inited = Boolean.TRUE;\n    }\n}\n...\n</code></pre>\n<p>\n一般には2つの <code>Boolean</code> オブジェクトだけが存在しています。\nこのコードは他の無関係なコードと同じオブジェクトで同期化している可能性があるので，無応答やデッドロックの原因になります。\n</p>\n<p>\nCERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\">CON08-J. Do not synchronize on objects that may be reused</a> を参照してください。\n</p>",
	"DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE":           "ボクシングされたプリミティブ値の同期化\n\n<p>\nこのコードは明らかに共有されていない <code>Integer</code> のようなボクシングされたプリミティブ型で同期化しています。\n</p>\n<pre><code>private static final Integer fileLock = new Integer(1);\n...\nsynchronized(fileLock) {\n    .. do something ..\n}\n...\n</code></pre>\n<p>\nこのコードは fileLock を次のように宣言するとより良くなります。\n</p>\n<pre><code>private static final Object fileLock = new Object();\n</code></pre>\n<p>\n既存のコードとしては間違っていないかもしれないが，紛らわしいので将来リファクタリングすべきかもしれません。\nたとえば，IntelliJ の \"Remove Boxing\" のようなリファクタリングは Java 仮想マシンを通して共有される正準化された <code>Integer</code> オブジェクトを使用するように置き換えてしまい，非常に紛らわしい振る舞いと潜在的デッドロックの原因になります。\n</p>",
	"DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE":                    "ボクシングされたプリミティブの同期化\n\n<p>\nこのコードは <code>Integer</code> のようなボクシングされたプリミティブの定数で同期化しています。\n</p>\n<pre><code>private static Integer count = 0;\n...\nsynchronized(count) {\n    count++;\n}\n...\n</code></pre>\n<p>\n<code>Integer</code> オブジェクトはキャッシュして共有できます。\n他の無関係なコードと同じオブジェクトで同期化している可能性があるので，無応答やデッドロックの原因になります。\n</p>\n<p>\nCERT <a href=\"https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused\">CON08-J. Do not synchronize on objects that may be reused</a> を参照してください。\n</p>",
	"ESync_EMPTY_SYNC":                                         "空の synchronized ブロック\n\n<p>\nこのコードには空の <code>synchronized</code> ブロックがあります。\n</p>\n<pre><code>synchronized() {\n}\n</code></pre>\n<p>\n空の synchronized ブロックは巧妙で正しく使用するのは困難です。\n空の synchronized ブロックはわざとらしくて決して良い解決策ではありません。\n</p>",
	"IS_INCONSISTENT_SYNC":                                     "一貫性のない同期化\n\n<p>\nこのクラスのフィールドは，同期化に関して一貫性のないアクセスをしているように見えます。\nこのバグレポートは，バグパターンディテクタが次のように判断したことを示します。\n</p>\n<ul>\n  <li>クラスにはロックされたアクセスとアンロックされたアクセスが混在していて</li>\n  <li>少なくとも1つのロックされたアクセスがクラス自身のメソッドの1つによって実行され， </li>\n  <li>読み出しの2倍の重み付けをした書き込みで，非同期フィールドのアクセス (読み出しと書き込み) 数がすべてのアクセスのわずか1/3</li>\n</ul>\n<p>\nこのバグパターンに合致する一般的なバグは，スレッドセーフを意図したクラスでメソッドを同期化するのを忘れていることです。\n</p>\n<p>\n不正確のいろいろなソースがこのディテクタにあることに注意してください。\nたとえば，ディテクタはロックを保持されるすべての状況を静的に検出できるわけではありません。\nまた，ディテクタがロックされたアクセスとアンロックされたアクセスの区別が正確なときでも，問題のコードはまだ正しいかもしれません。\n</p>",
	"ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD":            "フィールドを同期化でガードしようとする無駄な試み\n\n<p>\nこのメソッドは，フィールドの同時更新に対して同期化でガードしようとしています。しかし，フィールドをガードするとフィールドではなく，フィールドが参照するオブジェクトのロックを獲得します。\nこれはあなたが必要とする相互排除ができないかもしれません。\n他のスレッドは (他の目的のための) 参照されたオブジェクトのロックを獲得するかもしれません。<br>\nこのパターンの例は次のようになります。\n</p>\n<pre><code>private Long myNtfSeqNbrCounter = new Long(0);\nprivate Long getNotificationSequenceNumber() {\n     Long result = null;\n     synchronized(myNtfSeqNbrCounter) {\n         result = new Long(myNtfSeqNbrCounter.longValue() + 1);\n         myNtfSeqNbrCounter = new Long(result.longValue());\n     }\n     return result;\n}\n</code></pre>",
	"ML_SYNC_ON_UPDATED_FIELD":                                 "更新されるフィールドで同期化しているメソッド\n\n<p>\nこのメソッドは，可変フィールドから参照されたオブジェクトで同期化しています。\n異なるスレッドが異なるオブジェクトで同期化しているかもしれないので，有用な意味を持っている可能性が低いです。\n</p>",
	"MS_OOI_PKGPROTECT":                                        "インタフェースから移動してパッケージプロテクテッドにすべきフィールド\n\n<p>\nインタフェースに定義された <code>static final</code> フィールドが配列や <code>Hashtable</code> などの可変オブジェクトを参照しています。\nこの可変オブジェクトは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を回避するためにフィールドをクラスに移動して，パッケージプロテクテッドにする必要があります。\n</p>",
	"MS_FINAL_PKGPROTECT":                                      "final かつパッケージプロテクテッドにすべきフィールド\n\n<p>\nこの可変 <code>static</code> フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を回避するためにフィールドを <code>final</code> および/またはパッケージプロテクテッドにします。\n</p>",
	"MS_SHOULD_BE_REFACTORED_TO_BE_FINAL":                      "final ではないフィールドはリファクタリングすべき\n\n<p>\n<code>final</code> ではない <code>public static</code> フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を回避するためにフィールドを <code>final</code> にします。\nしかしながら，スタティックイニシャライザには複数のフィールドへの書き込みがあるので，何らかのリファクタリングを必要とするでしょう。\n</p>",
	"MS_SHOULD_BE_FINAL":                                       "final にすべきフィールド\n\n<p>\n<code>final</code> ではない <code>public static</code> フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を回避するためにフィールドを <code>final</code> にします。\n</p>",
	"MS_PKGPROTECT":                                            "パッケージプロテクテッドにすべきフィールド\n\n<p>\nこの可変 <code>static</code> フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を回避するためにフィールドをパッケージプロテクテッドにします。\n</p>",
	"MS_MUTABLE_HASHTABLE":                                     "可変 Hashtable のフィールド\n\n<p>\nこの <code>static final</code> フィールドは <code>Hashtable</code> を参照しているので，悪意のあるコードや別のパッケージによって思いがけずアクセスされる可能性があります。\nこのコードは<code>Hashtable</code> の内容を自由に変更できます。\n</p>",
	"MS_MUTABLE_COLLECTION":                                    "可変コレクションのフィールド\n\n<p>\n可変コレクションのインスタンスが <code>static final</code> フィールドに割り当てられています。\nしたがって，悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n脆弱性を避けるために <code>Collections.unmodifiableSet/List/Map</code> などでこのフィールドをラップすることを検討してください。\n</p>",
	"MS_MUTABLE_COLLECTION_PKGPROTECT":                         "パッケージプロテクテッドにすべき可変コレクションのフィールド\n\n<p>\n可変コレクションのインスタンスが <code>static final</code> フィールドに割り当てられています。\nしたがって，悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\nフィールドは脆弱性を避けるためにパッケージプロテクテッドにできます。\n脆弱性を避けるために <code>Collections.unmodifiableSet/List/Map</code> などでこのフィールドをラップすることを検討してください。\n</p>",
	"MS_MUTABLE_ARRAY":                                         "可変配列のフィールド\n\n<p>\nこの <code>static final</code> フィールドは配列を参照しているので，悪意のあるコードや別のパッケージによって思いがけずアクセスされる可能性があります。\nこのコードは配列の内容を自由に変更できます。\n</p>",
	"MS_CANNOT_BE_FINAL":                                       "final ではないフィールドは悪意のあるコードから保護できない\n\n<p>\nこの可変 <code>static</code> フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n残念ながらこのような使い方は簡単に解決できません。\n</p>",
	"ME_MUTABLE_ENUM_FIELD":                                    "列挙型フィールドは public で可変である\n\n<p>\n可変 <code>public</code> フィールドが <code>public</code> 列挙型の中に定義されています。\nしたがって，フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n可変列挙型フィールドが遅延初期化で使用されるかもしれないとしても外界へ暴露するバッドプラクティスです。\nこのメソッドを <code>final</code> およびパッケージプライベートとして宣言することを考えてください。\n</p>",
	"ME_ENUM_FIELD_SETTER":                                     "public 列挙型メソッドが無条件にフィールドを設定する\n\n<p>\n無条件に列挙型フィールドを設定している <code>public</code> 列挙型で <code>public</code> メソッドを宣言しています。\nしたがって，フィールドは悪意のあるコードや別のパッケージによって思いがけず変更される可能性があります。\n可変列挙型フィールドが遅延初期化で使用されるかもしれないとしても外界へ暴露するバッドプラクティスです。\nこのメソッドを除去するかパッケージプライベートとして宣言することを考えてください。\n</p>",
	"IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD":     "潜在的な継承されたメソッドなのか外部のメソッドなのかあいまいなメソッドの呼び出し\n\n<p>\n内部クラスは，継承されたメソッドか外部クラスで定義されたメソッドなのかどちらとも解釈できるメソッドを呼び出しています。\nたとえば， <code>foo(17)</code> を呼び出します。それはスーパークラスと外部のメソッドの両方で定義されています。\nJava のセマンティックスでは，継承したメソッドを呼び出しますが，これは意図したことではないかもしれません。\n</p>\n<p>\n本当に継承されたメソッドを呼び出すつもりなら <code>super</code> を付けて (例：<code>super.foo(17)</code>) 呼び出してください。\nそうすれば，外部クラスのメソッドではなく継承されたメソッドを呼び出したいことがこのコードを読む人と SpotBugs に明確になります。\n</p>\n<p>\n<code>this.foo(17)</code> を呼び出す場合は，継承されたメソッドが呼び出されます。\nしかしながら，SpotBugs はクラスファイルを見るだけなので， <code>this.foo(17)</code> と <code>foo(17)</code> の呼び出しの違いを見分けることができません。\n潜在的なあいまいな呼び出しについて文句を言うでしょう。\n</p>",
	"NM_SAME_SIMPLE_NAME_AS_SUPERCLASS":                        "クラス名はスーパークラスの単純名を遮るべきではない\n\n<p>\nこのクラスは，スーパークラスが異なるパッケージであるということを除いて，スーパークラスと同一の単純名です (たとえば， <code>alpha.Foo</code> が <code>beta.Foo</code> を拡張します)。\nこれは非常に紛らわしく，参照関係を解決するために <code>import</code> 文を見なければならなかったり，スーパークラスのメソッドをオーバーライドしないで誤ってメソッドを定義する状況を作り出します。\n</p>",
	"NM_SAME_SIMPLE_NAME_AS_INTERFACE":                         "クラス名は実装されたインタフェースの単純名を遮るべきではない\n\n<p>\nこのクラスまたはインタフェースは，インタフェースが異なるパッケージであるということを除いて実装された/拡張されたインタフェースと同一の単純名です (たとえば， <code>alpha.Foo</code> が <code>beta.Foo</code> を継承しているような状況です)。\nこれは非常に紛らわしく，参照関係を解決するために <code>import</code> 文を見なければならなかったり，スーパークラスのメソッドをオーバーライドしないで誤ってメソッドを定義する状況を作り出します。\n</p>",
	"NM_CLASS_NAMING_CONVENTION":                               "クラス名は大文字から始めるべき\n\n<p>\nクラス名は，最初の文字とそれに続く各単語の最初の文字を大文字にした名詞にすべきです。\nクラス名は単純でわかりやすいようにしてください。\n頭文字や略語 (URLやHTMLなどのように略語がロング形式よりもはるかに広く使われている場合を除く) の使用は避けてください。\n</p>",
	"NM_METHOD_NAMING_CONVENTION":                              "メソッド名は小文字から始めるべき\n\n<p>\nメソッド名は，最初の文字は小文字にし，それに続く各単語の最初の文字を大文字にした動詞にすべきです。\n</p>",
	"NM_FIELD_NAMING_CONVENTION":                               "フィールド名は小文字から始めるべき\n\n<p>\n<code>final</code> ではないフィールドの名前は，最初の文字は小文字にし，それに続く各単語の最初の文字を大文字にすべきです。\n</p>",
	"NM_VERY_CONFUSING":                                        "非常に紛らわしい名前のメソッド\n\n<p>\n参照されたメソッドは，大文字と小文字だけが異なる名前があります。\n大文字と小文字が同一ならメソッドの1つが他のメソッドをオーバーライドするので，非常に紛らわしいです。\n</p>",
	"NM_VERY_CONFUSING_INTENTIONAL":                            "非常に紛らわしい名前のメソッド (多分意図的)\n\n<p>\n参照されたメソッドは，大文字と小文字だけが異なる名前があります。\n大文字と小文字が同一ならメソッドの1つが他のメソッドをオーバーライドするので，非常に紛らわしいです。\n他のメソッドの存在から，これらのメソッドの両方の存在が意図的で，確実に混乱させていると思われます。\nAPIの凍結によって両方とも持たざるを得ない場合を除き，それらのうちの1つを除去しようと努力すべきです。\n</p>",
	"NM_WRONG_PACKAGE":                                         "パラメータの間違ったパッケージのためにスーパークラスのメソッドをオーバーライドしていないメソッド\n\n<p>\nパラメータの型がスーパークラスで対応するパラメータの型と正確に合致していないので，サブクラスのメソッドはスーパークラスの類似したメソッドをオーバーライドしていません。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>import alpha.Foo;\n\npublic class A {\n    public int f(Foo x) { return 17; }\n}\n----\nimport beta.Foo;\n\npublic class B extends A {\n    public int f(Foo x) { return 42; }\n}\n</code></pre>\n<p>\nクラス <code>B</code> で定義された <code>f(Foo)</code> メソッドは，クラス <code>A</code> の <code>f(Foo)</code> メソッドをオーバーライドしていません。\nこれは引数の型 <code>Foo</code> が違うパッケージだからです。\n</p>",
	"NM_WRONG_PACKAGE_INTENTIONAL":                             "パラメータの間違ったパッケージのためにスーパークラスのメソッドをオーバーライドしていないメソッド\n\n<p>\nパラメータの型が正確にスーパークラスで対応するパラメータの型と合致していないので，サブクラスのメソッドはスーパークラスの類似したメソッドをオーバーライドしていません。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>import alpha.Foo;\n\npublic class A {\n    public int f(Foo x) { return 17; }\n}\n----\nimport beta.Foo;\n\npublic class B extends A {\n    public int f(Foo x) { return 42; }\n    public int f(alpha.Foo x) { return 27; }\n}\n</code></pre>\n<p>\nクラス <code>B</code> で定義された <code>f(Foo)</code> メソッドは，クラス <code>A</code> の <code>f(Foo)</code> メソッドをオーバーライドしません。\nこれは引数の型 <code>Foo</code> が違うパッケージだからです。\n</p>\n<p>\nこの場合，サブクラスがスーパークラスのメソッドと同一のシグネチャでメソッドを定義しているので，おそらく理解できます。\nしかしながら，そのようなメソッドは非常に紛らわしいです。\n類似しているが同一ではないシグネチャのメソッドを除去するか，非推奨にすることを強く検討すべきです。\n</p>",
	"NM_CONFUSING":                                             "紛らわしい名前のメソッド\n\n<p>\n参照されたメソッドは，大文字と小文字だけが異なる名前があります。\n</p>",
	"NM_METHOD_CONSTRUCTOR_CONFUSION":                          "明らかなメソッドとコンストラクタの混乱\n\n<p>\nこの正規のメソッドは定義しているクラスと同じ名前です。\nこれはコンストラクタを意図していた可能性が高いです。もしそうなら <code>void</code> 戻り値の宣言を除去してください。<br>\n誤ってメソッドを定義したことが間違いだと気付き，適切なコンストラクタを定義したが，後方互換性のためにこのメソッドを除去できないならメソッドを非推奨にしてください。\n</p>",
	"NM_LCASE_HASHCODE":                                        "クラスは hashcode() を定義しています。hashCode() にすべきですか?\n\n<p>\nこのクラスは， <code>hashcode()</code> という名前のメソッドを定義しています。\nこのメソッドは， <code>java.lang.Object</code> の <code>hashCode</code> メソッドを (おそらく意図的に) オーバーライドしていません。\n</p>",
	"NM_LCASE_TOSTRING":                                        "クラスは tostring() を定義しています。toString() にすべきですか?\n\n<p>\nこのクラスは， <code>tostring()</code> という名前のメソッドを定義しています。\nこのメソッドは， <code>java.lang.Object</code> の <code>toString</code> メソッドを (おそらく意図的に) オーバーライドしていません。\n</p>",
	"NM_BAD_EQUAL":                                             "クラスは equal(Object) を定義しています。equals(Object) にすべきですか?\n\n<p>\nこのクラスは， <code>equal(Object)</code> という名前のメソッドを定義しています。\nこのメソッドは， <code>java.lang.Object</code> の <code>equals(Object)</code> を (おそらく意図的に) オーバーライドしていません。\n</p>",
	"NM_CLASS_NOT_EXCEPTION":                                   "例外クラスのように命名されているが，クラスは Exception から派生されていない\n\n<p>\nこのクラスは，例外クラスから派生されていないのにクラス名が「Exception」で終わっています。\nこのクラスのユーザが混乱するでしょう。\n</p>",
	"RR_NOT_CHECKED":                                           "InputStream.read() の戻り値を無視しているメソッド\n\n<p>\nこのメソッドは，複数バイトを返す可能性がある <code>java.io.InputStream.read()</code> (またはそのバリエーション) の戻り値を無視しています。\n戻り値がチェックされないと呼び出し元は要求したバイト数よりも少ないバイト数を読み出した場合，正しく処理できません。\nこれは潜在的なバグで，多くのプログラムでは，入力ストリームからの読み出しは，通常要求した完全なデータ量を読み出しますが，散発的に失敗することがあります。\n</p>",
	"SR_NOT_CHECKED":                                           "InputStream.skip() の戻り値を無視しているメソッド\n\n<p>\nこのメソッドは，複数バイトをスキップする可能性がある <code>java.io.InputStream.skip()</code> の戻り値を無視しています。\n戻り値がチェックされないと呼び出し元は要求したバイト数よりも少ないバイト数しかスキップしなかった場合，正しく処理できません。\nこれは潜在的なバグで，多くのプログラムでは，入力ストリームからのスキップは，通常要求した完全なデータ量をスキップをしますが，散発的に失敗することがあります。\nしかしながら，バッファードストリーム での <code>skip</code> メソッドはバッファのデータをスキップするので要求されたバイト数のスキップは常に失敗します。\n</p>",
	"SE_READ_RESOLVE_IS_STATIC":                                "readResolve メソッドが static メソッドとして宣言されている\n\n<p>\n<code>readResolve</code> メソッドが直列化機構で認識されるためには <code>static</code> メソッドとして宣言してはいけません。\n</p>",
	"SE_PRIVATE_READ_RESOLVE_NOT_INHERITED":                    "サブクラスで継承できない private な readResolve メソッド\n\n<p>\nこのクラスは， <code>private</code> な <code>readResolve</code> メソッドを定義しています。\nそのため，このメソッドはサブクラスで継承できません。\nこれが意図したことなら間違っていないかもしれませんが確認するためにレビューすべきです。\n</p>",
	"SE_READ_RESOLVE_MUST_RETURN_OBJECT":                       "readResolve メソッドの戻り値の型が Object で宣言されていない\n\n<p>\n<code>readResolve</code> メソッドが直列化機構で認識されるためには戻り値の型が <code>Object</code> で宣言されなければなりません。\n</p>",
	"SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS":              "Serializable ではないクラスの transient フィールド\n\n<p>\nフィールドは， <code>transient</code> と宣言していますが，クラスは直列化可能ではないので，まったく効果がありません。\nクラスが <code>transient</code> だったときの名残かもしれません，または直列化機構を誤解しているのかもしれません。\n</p>",
	"SE_TRANSIENT_FIELD_NOT_RESTORED":                          "直列化復元によって設定されない transient フィールド \n\n<p>\nこのクラスには複数の場所で更新されるフィールドがあります。したがって，このクラスの状態の一部だと思われます。\nしかしながら，フィールドは <code>transient</code> と宣言しているので， <code>readObject</code>/<code>readResolve</code> で値が設定されません。\nクラスの直列化復元されたインスタンスにはデフォルト値が設定されます。\n</p>",
	"SE_METHOD_MUST_BE_PRIVATE":                                "直列化機構のために private にしなければならないメソッド\n\n<p>\nこのクラスは， <code>Serializable</code> インタフェースを実装して，カスタム直列化/直列化復元のためのメソッドを定義しています。\nしかし，そのメソッドが <code>private</code> として宣言されていないので，直列化/直列化復元 API によって無視されます。\n</p>",
	"SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION":           "Externalizable なクラスが引数なしコンストラクタを定義していない\n\n<p>\nこのクラスは， <code>Externalizable</code> インタフェースを実装していますが，引数なしコンストラクタを定義していません。\n<code>Externalizable</code> オブジェクトが直列化復元されるときは，最初に引数なしコンストラクタを呼び出すことによって構築される必要があります。\nこのクラスには引数なしコンストラクタがないので，直列化と直列化復元は実行時に失敗します。\n</p>",
	"SE_NO_SUITABLE_CONSTRUCTOR":                               "Serializable なクラスのスーパークラスで，引数なしコンストラクタを定義していない\n\n<p>\nこのクラスは <code>Serializable</code> インタフェースを実装していますが，そのスーパークラスは実装していません。\nそのようなオブジェクトが直列化復元されるとき，スーパークラスのフィールドはスーパークラスの引数なしコンストラクタを呼び出すことによって初期化される必要があります。\nスーパークラスには引数なしコンストラクタがないので，直列化と直列化復元は実行時に失敗します。\n</p>",
	"SE_NO_SERIALVERSIONID":                                    "Serializable なクラスが serialVersionUID を定義していない\n\n<p>\nこのクラスは <code>Serializable</code> インタフェースを実装していますが， <code>serialVersionUID</code> フィールドを定義していません。\n.class オブジェクトへの参照を追加するのと同じくらい簡単な変更でクラスに合成フィールドを追加します。\nそれは，残念ながら暗黙の <code>serialVersionUID</code> を変えます (たとえば， <code>String.class</code> への参照を追加すると， <code>class$java$lang$String</code> という <code>static</code> フィールドを生成します)。\nまた，バイトコードコンパイラへの異なるソースコードは，クラスオブジェクトまたは内部クラスを参照するために生成される合成変数のために異なる命名規則を使用するかもしれません。\nバージョンを横断する <code>Serializable</code> の相互運用性を保証するために明示的に <code>serialVersionUID</code> を追加することを検討してください。\n</p>",
	"SE_COMPARATOR_SHOULD_BE_SERIALIZABLE":                     "Comparator は Serializable を実装していない\n\n<p>\nこのクラスは <code>Comparator</code> インタフェースを実装しています。\n<code>Serializable</code> インタフェースも実装する必要があるのか検討すべきです。\nコンパレータが <code>TreeMap</code> のような順序付きコレクションを構築するために使われるなら，コンパレータが直列化可能な場合だけ， <code>TreeMap</code> は直列化可能です。\n大部分のコンパレータがほとんど状態を持たないとしても直列化可能にすることは簡単で良い防衛的なプログラミングです。\n</p>",
	"SF_SWITCH_FALLTHROUGH":                                    "1つの case が次の case へと通り抜ける switch 文を見つけた\n\n<p>\nこのメソッドには1つの <code>case</code> が次の <code>case</code> へと通り抜ける <code>switch</code> 文があります。\n通常は， <code>break</code> か <code>return</code> でこの <code>case</code> を終わらせる必要があります。\n</p>",
	"SF_SWITCH_NO_DEFAULT":                                     "default がない switch 文を見つけた\n\n<p>\nこのメソッドには <code>default</code> がない <code>switch</code> 文があります。\n通常は， <code>default</code> を用意する必要があります。\n</p>\n<p>\n解析は生成されたバイトコードを見るだけなので， <code>default</code> が <code>switch</code> 文の終わりにあって，他のケースに <code>break</code> 文が含まれていないなら誤検出のトリガーとなります。\n</p>",
	"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH":                  "switch 文のフォールスルーのために格納が無効になっている\n\n<p>\n前の <code>case</code> で格納された値が <code>switch</code> 文のフォールスルーのためにここで上書きされています。\n前の <code>case</code> の終わりに <code>break</code> または <code>return</code> を入れるのを忘れた可能性があります。\n</p>",
	"SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW":         "スローする switch 文のフォールスルーのために格納が無効になっている\n\n<p>\n前の <code>case</code> で格納された値が例外がスローされる場所で， <code>switch</code> 文のフォールスルーのためにここで失われています。\n前の <code>case</code> の終わりに <code>break</code> または <code>return</code> を入れるのを忘れた可能性があります。\n</p>",
	"WS_WRITEOBJECT_SYNC":                                      "writeObject メソッドは同期化しているがその他のメソッドは同期化していないクラス\n\n<p>\nこのクラスには同期化している <code>writeObject</code> メソッドがあります。\nしかしながら，クラスのその他のメソッドは同期化していません。\n</p>",
	"RS_READOBJECT_SYNC":                                       "readObject メソッドを同期化しているクラス\n\n<p>\nこの直列化可能クラスは同期化している <code>readObject</code> メソッド を定義しています。\n直列化復元によって作成されるオブジェクトは1つのスレッドによってだけ到達可能です。\nしたがって， <code>readObject</code> メソッドは同期化する必要がありません。\n<code>readObject</code> メソッドそのものが別のスレッドに見えるようになるオブジェクトの原因になっているなら非常に疑わしいコーディングスタイルの例です。\n</p>",
	"SE_NONSTATIC_SERIALVERSIONID":                             "serialVersionUID が static ではない\n\n<p>\nこのクラスは， <code>static</code> ではない <code>serialVersionUID</code> フィールドを定義しています。\n直列化を目的としてバージョン UID を指定することを意図しているならフィールドは <code>static</code> とすべきです。\n</p>",
	"SE_NONFINAL_SERIALVERSIONID":                              "serialVersionUID が final ではない\n\n<p>\nこのクラスは， <code>final</code> ではない <code>serialVersionUID</code> フィールドを定義しています。\n直列化を目的としてバージョン UID を指定することを意図しているならフィールドは <code>final</code> とすべきです。\n</p>",
	"SE_NONLONG_SERIALVERSIONID":                               "serialVersionUID が long ではない\n\n<p>\nこのクラスは， <code>long</code> ではない <code>serialVersionUID</code> フィールドを定義しています。\n直列化を目的としてバージョン UID を指定することを意図しているならフィールドは <code>long</code> とすべきです。\n</p>",
	"SE_BAD_FIELD":                                             "直列化可能クラスの非 transient で非直列化可能なインスタンスフィールド\n\n<p>\nこの直列化可能クラスは， <code>transient</code> ， <code>Serializable</code> ， <code>java.lang.Object</code> でもない非プリミティブ型のインスタンスフィールドを定義して，\n<code>Externalizable</code> インタフェースまたは <code>readObject</code> メソッドと <code>writeObject</code> メソッドを実装するように見えません。\nまた， <code>Externalizable</code> インタフェースも実装していなくて， <code>readObject</code> メソッドも <code>writeObject</code> メソッドも定義していません。\n非直列化可能オブジェクトがこのフィールドに格納されるならクラスのオブジェクトは正しく直列化復元されません。\n</p>",
	"SE_BAD_FIELD_INNER_CLASS":                                 "非直列化可能クラスに直列化可能な内部クラスがある\n\n<p>\nこの直列化可能クラスは，非直列化可能クラスの内部クラスです。\n内部クラスを直列化しようとすると関連する外部クラスのインスタンスを結びつけようとするので，実行時エラーの原因になります。\n</p>\n<p>\nできれば，内部クラスを <code>static</code> にして問題を解決すべきです。\n外部クラスの直列化は動作可能かもしれませんが，内部クラスのインスタンスを直列化することは，外部クラスのインスタンスも常に直列化することを意味します。\n本当に望むことですか。\n</p>",
	"SE_INNER_CLASS":                                           "直列化可能な内部クラス\n\n<p>\nこの直列化可能なクラスは内部クラスです。内部クラスを直列化しようとすると関連した外部クラスのインスタンスも直列化します。\n外部クラスのインスタンスは直列化可能なので失敗しません。しかし，意図していたよりももっと多くのデータを直列化するかもしれません。\nできれば，内部クラスを <code>static</code> にして問題を解決すべきです。\n</p>",
	"SE_BAD_FIELD_STORE":                                       "非直列化可能な値を直列化可能クラスのインスタンスフィールドに格納している\n\n<p>\n非直列化可能な値を直列化可能クラスの 非 <code>transient</code> フィールドに格納しています。\n</p>",
	"SC_START_IN_CTOR":                                         "Thread.start() を呼び出しているコンストラクタ\n\n<p>\nコンストラクタがスレッドを開始しています。クラスが拡張され，サブクラスが作られるなら間違っていそうです。\nなぜなら，サブクラスのコンストラクタでスレッドが開始される前にスーパークラスのスレッドが開始されてしまうためです。\n</p>",
	"SS_SHOULD_BE_STATIC":                                      "読み出されないフィールド\n\n<p>\nこのクラスにはコンパイル時に静的な値に初期化されるインスタンス <code>final</code> フィールドがあります。\n<code>static</code> フィールドにすることを検討してください。\n</p>",
	"UUF_UNUSED_FIELD":                                         "未使用のフィールド\n\n<p>\nこのフィールドは決して使用されません。クラスから除去することを検討してください。\n</p>",
	"URF_UNREAD_FIELD":                                         "読み出されないフィールド\n\n<p>\nこのフィールドは決して読み出されません。クラスから除去することを検討してください。\n</p>",
	"UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD":                     "未使用の public または protected フィールド\n\n<p>\nこのフィールドは決して使用されません。\nフィールドが <code>public</code> か <code>protected</code> なので，多分，それは解析の一部として見えないクラスで使用されることを意図しています。\nそうでなければ，クラスから除去することを検討してください。\n</p>",
	"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD":                     "読み出されない public または protected フィールド\n\n<p>\nこのフィールドは決して読み出されません。\nフィールドが <code>public</code> か <code>protected</code> なので，多分，それは解析の一部として見えないクラスで使用されることを意図しています。\nそうでなければ，クラスから除去することを検討してください。\n</p>",
	"QF_QUESTIONABLE_FOR_LOOP":                                 "複雑か巧妙か間違ったインクリメントの for ループ\n\n<p>\n本当にこの <code>for</code> ループが正しい変数をインクリメントしていますか？\n別の変数が <code>for</code> ループによって初期化されてチェックされるように見えます。\n</p>",
	"UWF_NULL_FIELD":                                           "null に設定されるだけのフィールド\n\n<p>\nこのフィールドに定数値 <code>null</code> を書き込みます。したがって，フィールドの読み出しは <code>null</code> を返します。\n誤りをチェックしてください。役に立たないなら除去してください。\n</p>",
	"UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD":                  "書き込まてれいない public または protected フィールド\n\n<p>\nこの <code>public</code> または <code>protected</code> フィールドは書き込まれていません。このフィールドからの読み出しはデフォルト値を返します。\n誤りをチェックしてください (フィールドは初期化すべきでしたか？)。役に立たないなら除去してください。\n</p>",
	"UWF_UNWRITTEN_FIELD":                                      "書き込まれていないフィールド\n\n<p>\nこのフィールドは決して書き込まれません。このフィールドからの読み出しはデフォルト値を返します。\n誤りをチェックしてください (フィールドは初期化すべきでしたか？)。役に立たないなら除去してください。\n</p>",
	"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD":                  "インスタンスメソッドから static フィールドへの書き込み\n\n<p>\nこのインスタンスメソッドは， <code>static</code> フィールドに書き込みをしています。\n複数のインスタンスが操作されているなら，正しくさせるのは難しいです。一般的にバッドプラクティスです。\n</p>",
	"NP_LOAD_OF_KNOWN_NULL_VALUE":                              "null とわかっている値のロード\n\n<p>\nここで参照されている変数は，以前に <code>null</code> なのかチェックしているため <code>null</code> であることがわかっています。\nこれは有効ですが，間違いかもしれません (多分異なる変数を参照することを意図していました。あるいは，以前の <code>null</code> チェックで <code>null</code> ではないのか確かめるべきでした)。\n</p>",
	"NP_DEREFERENCE_OF_READLINE_VALUE":                         "readLine メソッドの結果が null なのか確かめないで値を利用している\n\n<p>\n<code>readLine</code> メソッドの結果が <code>null</code> なのか確かめないで値を利用しています。\n<code>readLine</code> メソッドは，それ以上読み出すテキスト行がなければ <code>null</code> を返すので， <code>NullPointerException</code> が発生します。\n</p>",
	"NP_IMMEDIATE_DEREFERENCE_OF_READLINE":                     "readLine メソッドの結果をすぐに利用している\n\n<p>\n<code>readLine</code> メソッドの結果をすぐに利用しています。\n<code>readLine</code> メソッドは，それ以上読み出すテキスト行がなければ <code>null</code> を返すので， <code>NullPointerException</code> が発生します。\n</p>",
	"NP_UNWRITTEN_FIELD":                                       "書き込まれていないフィールドの読み出し\n\n<p>\nプログラムは，決して <code>null</code> ではない値を書き込むとは思われないフィールドの値を利用しています。\nフィールドが解析によって見られないメカニズムを通して初期化されないかぎり，この値を利用すると <code>NullPointerException</code> が発生します。\n</p>",
	"NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD":                   "書き込まれていない public または protected フィールドの読み出し\n\n<p>\nプログラムは，決して <code>null</code> 値ではない値を書き込むと思われない <code>public</code> または <code>protected</code> フィールドの <code>null</code> 値を利用しています。\nフィールドが解析によって見られないメカニズムを通して初期化されないかぎり，この値を利用すると <code>NullPointerException</code> が発生します。\n</p>",
	"SIC_THREADLOCAL_DEADLY_EMBRACE":                           "非 static 内部クラスとスレッドローカルのデッドロック\n\n<p>\nこのクラスは内部クラスですが，おそらく <code>static</code> 内部クラスにすべきです。\n実際には内部クラスと外部クラスのスレッドローカルとの間にデッドロックの深刻な危険性があります。\n内部クラスが <code>static</code> ではないので，外部クラスへの参照を保持します。\nスレッドローカルに内部クラスのインスタンスの参照があるなら，内部と外部のインスタンスの両方が到達可能になり，ガベージされません。\n</p>",
	"SIC_INNER_SHOULD_BE_STATIC":                               "static 内部クラスにすべき\n\n<p>\nこのクラスは内部クラスなのにそれを作成したオブジェクトへの埋め込まれた参照を使用していません。\nこの参照はより大きなクラスのインスタンスを作成して，不必要に作成オブジェクトへの参照を存続しておくことがあります。\nできれば，クラスは <code>static</code> にすべきです。\n</p>",
	"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR":                 "コンストラクタで初期化されていないフィールドを null チェックなしで null 値を利用している\n\n<p>\nこのフィールドは，どんなコンストラクタの中でも決して初期化されません。したがって，オブジェクトが構築された後， <code>null</code> である可能性があります。\nどこかほかで，値がロードされて， <code>null</code> チェックなしで <code>null</code> 値が利用されます。\nフィールドが初期化される前に利用されると <code>NullPointerException</code> が発生するので，誤りか疑わしい設計かもしれません。\n</p>",
	"SIC_INNER_SHOULD_BE_STATIC_ANON":                          "名前付き static 内部クラスにリファクタリングできるかもしれない\n\n<p>\nこのクラスは内部クラスなのにそれを作成したオブジェクトへの埋め込まれた参照を使用していません。\nこの参照はより大きなクラスのインスタンスを作成して，不必要に作成オブジェクトへの参照を存続しておくことがあります。\nできれば，クラスは <code>static</code> 内部クラスにすべきです。\n無名内部クラスは <code>static</code> にできないので，名前付き内部クラスにリファクタリングする必要があります。\n</p>",
	"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS":                    "static 内部クラスにリファクタリングできるかもしれない\n\n<p>\nこのクラスは内部クラスなのにそれを作成したオブジェクトへの埋め込まれた参照を使用していません。\nこの参照はより大きなクラスのインスタンスを作成して，不必要に長く作成オブジェクトへの参照を存続しておくかもしれません。\nできれば，クラスは <code>static</code> 内部クラスにすべきです。\n外部オブジェクトへの参照が内部クラスのインスタンスを構築する間必要なので内部クラスのコンストラクタに外部インスタンスへの参照を渡すようにリファクタリングする必要があります。\n</p>",
	"WA_NOT_IN_LOOP":                                           "wait メソッドがループの中にない\n\n<p>\nこのメソッドは，ループの中にない <code>java.lang.Object.wait()</code> を呼び出しています。\nモニタが複数の条件のために使われるなら，呼び出し元が待機するつもりだった条件は実際には発生しないかもしれません。\n</p>",
	"WA_AWAIT_NOT_IN_LOOP":                                     "Condition.await() がループの中にない\n\n<p>\nこのメソッドは，ループの中にない <code>java.util.concurrent.await()</code> (またはそのバリエーション) を呼び出しています。\nオブジェクトが複数の条件のために使われるなら，呼び出し元が待機するつもりだった条件は実際には発生しないかもしれません。\n</p>",
	"NO_NOTIFY_NOT_NOTIFYALL":                                  "notifyAll メソッドではなく notify メソッドを使用している\n\n<p>\nこのメソッドは， <code>notifyAll</code> メソッドではなく <code>notify</code> メソッドを呼び出しています。\nモニターは，複数の条件で使われることがよくあります。\n<code>notify</code> メソッドの呼び出しは1つのスレッドを起こすだけで起こされたスレッドは呼び出し元が満たした待機条件の1つではないかもしれないことを意味しています。\n</p>",
	"UC_USELESS_VOID_METHOD":                                   "役に立たない空ではない void メソッド\n\n<p>\n我々の解析は，この空ではない <code>void</code> メソッドが実際に有用な仕事を行わないことを示しています。\n確認してください。おそらくそのコードが間違っているか，またはボディを完全に除去できます。\n</p>\n<p>\n我々はできる限り誤検出を減らそうと努力しているが，いくつかのケースでは警告は間違っているかもしれません。\nよくある誤検出例です。\n</p>\n<ul>\n  <li>メソッドは，副作用を持つかもしれないクラスのロードをトリガーすることを意図している</li>\n  <li>メソッドは，暗黙のわかりにくい例外をスローするように意図されている</li>\n</ul>",
	"UC_USELESS_CONDITION":                                     "条件は効果がない\n\n<p>\nこの条件は前に絞られた関係している変数の値と同じ結果を常に作り出します。\nおそらく何かほかのことを意味していたのか，あるいは条件を除去できます。\n</p>",
	"UC_USELESS_CONDITION_TYPE":                                "条件は変数型のために効果がない\n\n<p>\nこの条件は関係している変数の型範囲のために同じ結果を常に作り出します。\nおそらく何かほかのことを意味していたのか，あるいは条件を除去できます。\n</p>",
	"UC_USELESS_OBJECT":                                        "役に立たないオブジェクトを作成した\n\n<p>\n我々の解析でオブジェクトが役に立たないことを示しています。\n作成され，変更されていますが，値はメソッドの外に出ないし，副作用をもたらしません。\n間違いかオブジェクトが使われることを意図していたかのどちらか，あるいは除去できます。\n</p>\n<p>\nこの解析はめったに誤検出することはありません。よくある誤検出のケースです。\n</p>\n<ul>\n  <li>暗黙のうちに曖昧な例外をスローした</li>\n  <li>コードを一般化してスタブとして使用された</li>\n  <li>弱/ソフト参照オブジェクトへの強い参照を持っていた</li>\n</ul>",
	"UC_USELESS_OBJECT_STACK":                                  "役に立たないオブジェクトをスタックで作成した\n\n<p>\nこのオブジェクトは副作用を持たない変更を行うために作成されています。\nおそらく何かほかのことを意味していたのか，あるいはオブジェクトを除去できます。\n</p>",
	"RANGE_ARRAY_INDEX":                                        "配列インデックスは範囲外\n\n<p>\n配列操作が行なわれていますが，配列インデックスが範囲外なので実行時に <code>ArrayIndexOutOfBoundsException</code> が発生するでしょう。\n</p>",
	"RANGE_ARRAY_OFFSET":                                       "配列オフセットは範囲外\n\n<p>\nメソッドは，配列パラメータとオフセットパラメータで呼び出されていますが，オフセットは範囲外です。\n実行時に <code>IndexOutOfBoundsException</code> が発生するでしょう。\n</p>",
	"RANGE_ARRAY_LENGTH":                                       "配列の長さは範囲外\n\n<p>\nメソッドは，配列パラメータと長さパラメータで呼び出されていますが，長さは範囲外です。\n実行時に <code>IndexOutOfBoundsException</code> が発生するでしょう。\n</p>",
	"RANGE_STRING_INDEX":                                       "文字列インデックスは範囲外\n\n<p>\n文字列メソッドが呼び出されていますが，指定された文字列インデックスは範囲外です。\n実行時に <code>StringIndexOutOfBoundsException</code> が発生するでしょう。\n</p>",
	"RV_CHECK_FOR_POSITIVE_INDEXOF":                            "String.indexOf の結果が正かどうか確かめている\n\n<p>\nこのメソッドは <code>String.indexOf</code> を呼び出して結果が正かどうか確かめています。\n結果が負かどうか確かめるほうがはるかに一般的です。チェックされる部分文字列が <code>String</code> の先頭以外の場所で出現するときだけ正になります。\n</p>",
	"RV_DONT_JUST_NULL_CHECK_READLINE":                         "readLine メソッドの結果を null ではないのか確かめた後で捨てている\n\n<p>\n<code>readLine</code> メソッドの戻り値を <code>null</code> ではないのか確かめた後で捨てています。\nほとんどすべての状況で，結果が <code>null</code> ではないなら戻り値を使用したいでしょう。\n再び <code>readLine</code> メソッドを呼び出すと異なる行が得られます。\n</p>",
	"RV_RETURN_VALUE_IGNORED_INFERRED":                         "メソッドは戻り値を無視しています。これは間違いではないですか?\n\n<p>\nこのコードはメソッドを呼び出して，戻り値を無視しています。\n戻り値は，メソッドが呼び出される型と同じ型です。そして，我々の解析から戻り値が重要であるかもしれないように見えます （たとえば， <code>String.toLowerCase()</code> の戻り値を無視するような）。\n</p>\n<p>\n我々は，戻り値を無視することがメソッド本体の単純な解析から悪い考えかもしれないと推測しています。\nこのメソッドの戻り値を無視することが重要であるか許容できるかどうかに関して，SpotBugs に指示する <code>@CheckReturnValue</code> アノテーションが使えます。\n</p>\n<p>\n戻り値を無視することが間違いではないか決めるために厳密に調査してください。\n</p>",
	"RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT":                   "副作用がないメソッドの戻り値は無視される\n\n<p>\nこのコードはメソッドを呼び出して戻り値を無視しています。\nしかしながら，解析はメソッド (もしあればサブクラスの実装も含む) が戻り値以外の効果をもたらさないことを示しています。\nこの呼び出しは除去できます。\n</p>\n<p>\n我々は，できる限り誤検出を減らそうとしていますが，いくつかのケースではこの警告が間違っているかもしれません。\nよくある誤検出です。\n</p>\n<ul>\n  <li>メソッドは，オーバライドされ解析対象外の他のプロジェクトで副作用がもたらされるように設計されている</li>\n  <li>メソッドは，副作用をもたらすかもしれないクラスローダをトリガーするように呼び出されている</li>\n  <li>メソッドは，例外を取得するために呼び出されている</li>\n</ul>\n<p>\n我々の仮定が正しくないと感じるなら，SpotBugs にこのメソッドの戻り値が無視されることを許容するように指示する <code>@CheckReturnValue</code> アノテーションを使用することができます。\n</p>",
	"RV_RETURN_VALUE_IGNORED":                                  "戻り値を無視しているメソッド\n\n<p>\nこのメソッドの戻り値はチェックすべきです。\nこの警告の共通の原因は，オブジェクトが更新されると思って不変オブジェクトのメソッドを呼び出すことです。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>String dateString = getHeaderField(name);\ndateString.trim();\n</code></pre>\n<p>\nプログラマは， <code>trim</code> メソッドが <code>dateString</code> によって参照される <code>String</code> オブジェクトが更新されると思っています。\nしかし， <code>String</code> オブジェクトは不変で， <code>trim</code> メソッドが新しい <code>String</code> オブジェクトを返すのに無視しています。\nこのコードは次のように修正すべきです。\n</p>\n<pre><code>String dateString = getHeaderField(name);\ndateString = dateString.trim();\n</code></pre>",
	"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE":                     "例外的戻り値を無視しているメソッド\n\n<p>\nこのメソッドはチェックされていない値を返しています。\n戻り値は異常か予想外の実行結果を示す可能性があるのでチェックすべきです。\nたとえば， <code>File.delete()</code> はファイルをうまく削除できなかったなら，例外をスローするのではなく <code>false</code> を返します。\n結果をチェックしないなら例外的戻り値を返すメソッドの呼び出しで予想外の振る舞いの合図に気づきません。\n</p>",
	"RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE":             "compareTo によって返された特定の値のコードチェック\n\n<p>\nこのコードは <code>compareTo</code> または <code>compare</code> メソッドを呼び出して，戻り値が特定の値（たとえば1または-1） なのか確かめています。\nこれらのメソッドを呼び出すときは特定のゼロ以外の値ではなく，結果の符号だけをチェックすべきです。\n多数または大部分の <code>compareTo</code> と比較メソッドは-1，0または1を返しますが，いくつかは他の値を返します。\n</p>",
	"RV_EXCEPTION_NOT_THROWN":                                  "作成した例外をスローするのではなく捨てている\n\n<p>\nこのコードは例外 (またはエラー) オブジェクトを作成していますが，何もしていません。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>if (x &lt; 0) {\n    new IllegalArgumentException(\"x must be nonnegative\");\n}\n</code></pre>\n<p>\nおそらくプログラマの意図は，作成した例外をスローすることでした。\n</p>\n<pre><code>if (x &lt; 0) {\n    throw new IllegalArgumentException(\"x must be nonnegative\");\n}\n</code></pre>",
	"NP_ALWAYS_NULL":                                           "null 値を利用している\n\n<p>\nここで <code>null</code> 値を利用しようとしています。\nコードが実行されると <code>NullPointerException</code> が発生します。\n</p>",
	"NP_CLOSING_NULL":                                          "常に null 値のオブジェクトで close メソッドを呼び出している\n\n<p>\n<code>close</code> メソッドは，常に <code>null</code> 値のオブジェクトで呼び出されています。\nこの文が実行されるなら <code>NullPointerException</code> が発生します。\nここでクローズすべき何かを決してクローズしないという大きな危険性があります。\n</p>",
	"NP_STORE_INTO_NONNULL_FIELD":                              "@Nonnull アノテーションが付けられたフィールドに null を格納している\n\n<p>\n<code>@Nonnull</code> アノテーションが付けられたフィールドに <code>null</code> かもしれない値を格納しています。\n</p>",
	"NP_ALWAYS_NULL_EXCEPTION":                                 "null 値を例外経路で利用している\n\n<p>\n例外経路上のここで <code>null</code> 値を利用しています。コードが実行されると <code>NullPointerException</code> が発生します。\n現在の SpotBugs は実行不可能な例外経路を刈り取れていないので，誤検出かもしれないことに注意してください。\n</p>\n<p>\n<code>switch</code> 文の <code>default</code> が多くの場合実行不可能なので SpotBugs が例外経路である <code>default</code> を検討することに注意して下さい。\n</p>",
	"NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE":      "パラメータは  非 null でなければならないが null 可能としてマークされている\n\n<p>\nこのパラメータは，常に 非 <code>null</code> にすることを要求する方法で使われていますが，パラメータには明示的に <code>Nullable</code> アノテーションが付けられています。\nパラメータかアノテーションのどちらかの使い方が間違っています。\n</p>",
	"NP_NULL_ON_SOME_PATH":                                     "null 値を利用している可能性がある\n\n<p>\nそこで分岐または文が実行されるなら <code>null</code> 値が利用されて <code>NullPointerException</code> が発生します。\nもちろん，問題は分岐または文が実行不可能で， <code>NullPointerException</code> が決して発生する可能性がないということかもしれません。\nそれを決めるのは SpotBugs の能力を超えています。\n</p>",
	"NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE":                 "null 値を実行不可能かもしれない分岐で利用している可能性がある\n\n<p>\nそこで分岐または文が実行されるなら， <code>null</code> 値が利用されて <code>NullPointerException</code> が発生します。\nもちろん，問題は分岐または文が実行不可能で， <code>NullPointerException</code> が決して発生する可能性がないということかもしれません。\nそれを決めるのは SpotBugs の能力を超えています。\nこの値が既に <code>null</code> であることを検査したという事実からこれは明確な可能性です。\n</p>",
	"NP_NULL_ON_SOME_PATH_EXCEPTION":                           "null 値を例外経路で利用している可能性がある\n\n<p>\n例外経路上のここで <code>null</code> 値が利用されています。コードが実行されると <code>NullPointerException</code> を引き起こすことがあります。\n現在の SpotBugs は実行不可能な例外経路を刈り取れていないので，誤検出かもしれないことに注意してください。\n</p>\n<p>\n<code>switch</code> 文の <code>default</code> が多くの場合実行不可能なので SpotBugs が例外経路である <code>default</code> を検討することに注意して下さい。\n</p>",
	"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE":                   "null になっている可能性があるメソッドの戻り値を利用している\n\n<p>\nメソッドからの戻り値を <code>null</code> チェックしないで利用しています。メソッドの戻り値は <code>null</code> なのかチェックすべきです。\nコードが実行されると <code>NullPointerException</code> を引き起こすことがあります。\n</p>",
	"NP_NULL_PARAM_DEREF_NONVIRTUAL":                           "非 null パラメータに null を渡している非仮想メソッドの呼び出し\n\n<p>\n<code>null</code> の可能性がある値が 非 <code>null</code> メソッドパラメータに渡されています。\nパラメータは，常に非 <code>null</code> とすべきパラメータとしてアノテーションが付けられていたか，解析が常に <code>null</code> 値を利用することを示していました。\n</p>",
	"NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS":                "メソッド呼び出しは非 null パラメータに null を渡している\n\n<p>\nすべての既知のターゲットメソッドが非 <code>null</code> であることをパラメータに要求する呼び出し場所で，おそらく <code>null</code> 値を渡しています。\nパラメータは，常に非 <code>null</code> とすべきパラメータとしてアノテーションが付けられていたか，解析が常に <code>null</code> 値を利用することを示していました。\n</p>",
	"NP_NULL_PARAM_DEREF":                                      "メソッド呼び出しは非 null パラメータに null を渡している\n\n<p>\nこのメソッド呼び出しは非 <code>null</code> メソッドパラメータに <code>null</code> 値を渡しています。\nパラメータは，常に非 <code>null</code> とすべきパラメータとしてアノテーションが付けられていたか，解析が常に <code>null</code> 値を利用することを示していました。\n</p>",
	"NP_NONNULL_PARAM_VIOLATION":                               "メソッド呼び出しは非 null パラメータに null を渡している\n\n<p>\nこのメソッドは，非 <code>null</code> でなければならないメソッドのパラメータとして <code>null</code> 値を渡しています。\nこのパラメータは，明示的に <code>@Nonnull</code> アノテーションが付けられていたか，解析が常に <code>null</code> 値を利用することを示していました。\n</p>",
	"NP_NONNULL_RETURN_VIOLATION":                              "null を返すかもしれないメソッドが @Nonnull 宣言されている\n\n<p>\nこのメソッドは， <code>null</code> 値を返すかもしれないのにメソッド (またはスーパークラスのメソッド) の戻り値に <code>@Nonnull</code> が宣言されています。\n</p>",
	"NP_CLONE_COULD_RETURN_NULL":                               "null を返すかもしれない clone メソッド\n\n<p>\nこの <code>clone</code> メソッドは，いくつかの条件で <code>null</code> を返すと思われます。\nしかし， <code>clone</code> メソッドは決して <code>null</code> を返すのは許されません。\nこの経路が到達できないことを確信しているなら，代わりに <code>AssertionError</code> をスローしてください。\n</p>",
	"NP_TOSTRING_COULD_RETURN_NULL":                            "null を返すかもしれない toString メソッド\n\n<p>\nこの <code>toString</code> メソッドは，いくつかの条件で <code>null</code> を返すと思われます。\n仕様を寛大に読むとこれが許されると解釈できるかもしれませんが，それはおそらく間違った考えで，他のコードが壊れる原因になる可能性があります。\n<code>null</code> ではなく空の文字列，または，いくつかの他の適切な文字列を返してください。\n</p>",
	"NP_GUARANTEED_DEREF":                                      "null 値を利用することが保証されている\n\n<p>\n文または分岐が実行されるなら，この時点で値は <code>null</code> であり， <code>null</code> 値を利用する ことが保証されています (実行時例外を含むフォワードパスを除く)。\n</p>\n<p>\nなお， <code>if (x == null) throw new NullPointerException();</code> は <code>x</code> の参照解除として扱われることに注意して下さい。\n</p>",
	"NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH":                    "null 値を例外経路で利用することが保証されている\n\n<p>\n例外経路上の文または分岐が実行されるなら，この時点で値は <code>null</code> であり， <code>null</code> 値を利用することが保証されています (実行時例外を含むフォワードパスを除く)。\n</p>",
	"SI_INSTANCE_BEFORE_FINALS_ASSIGNED":                       "スタティックイニシャライザは，すべての static final フィールドが代入される前にインスタンスを作成する\n\n<p>\nすべての <code>static final</code> フィールドが初期化される前にスタティックイニシャライザがクラスのインスタンスを作成します。\n</p>",
	"OS_OPEN_STREAM":                                           "ストリームのクローズに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，入出力ストリームオブジェクトを作成していますが，任意のフィールドに割り当てたり，クローズする可能性のある別のメソッドに渡したり，返すことはなく，メソッドからのすべての経路でクローズするように見えません。\nこれはファイルディスクリプタリークの原因になることがあります。\nストリームがクローズされることを確実にするために <code>finally</code> ブロックを使用することは一般的に良い考えです。\n</p>",
	"OS_OPEN_STREAM_EXCEPTION_PATH":                            "例外経路でストリームのクローズに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，入出力ストリームオブジェクトを作成していますが，任意のフィールドに割り当てたり，クローズする可能性のある別のメソッドに渡したり，返すことはなく，メソッドからのすべての例外経路でクローズするように見えません。\nこれはファイルディスクリプターリークの原因になることがあります。\nストリームがクローズされることを確実にするために <code>finally</code> ブロックを使用することは一般的に良い考えです。\n</p>",
	"PZLA_PREFER_ZERO_LENGTH_ARRAYS":                           "null ではなく長さが0の配列を返すことを検討する\n\n<p>\n結果がないこと (すなわち，結果の空のリスト) を示すために <code>null</code> 参照ではなく長さが0の配列 を返すことは，多くの場合より良い設計です。\nこのように，メソッドのクライアントは明示的に <code>null</code> チェックをする必要はありません。\n</p>\n<p>\n一方，「この質問に対する答えがない」ことを示すために <code>null</code> を使用することはおそらく適切です。\nたとえば， <code>File.listFiles()</code> は，ファイルがないディレクトリを与えられた場合は空のリストを返し，ファイルがディレクトリではないなら <code>null</code> を返します。\n</p>",
	"UCF_USELESS_CONTROL_FLOW":                                 "役に立たない制御フロー\n\n<p>\nこのメソッドには分岐するのかどうかに関係なく，制御フローが同じ場所へと続く，役に立たない制御フロー文があります。<br>\nたとえば，これは 空の <code>if</code> 文が原因になります。\n</p>\n<pre><code>if (argv.length == 0) {\n    // TODO: handle this case\n}\n</code></pre>",
	"UCF_USELESS_CONTROL_FLOW_NEXT_LINE":                       "次の行へ続くだけの役に立たない制御フロー\n\n<p>\nこのメソッドには分岐するのかどうかに関係なく，制御フローが同じか次の行へと続く，役に立たない制御フロー文があります。<br>\n多くの場合，不注意に <code>if</code> 文の本体を空文を使用したことが原因になります。\n</p>\n<pre><code>if (argv.length == 1);\n    System.out.println(\"Hello, \" + argv[0]);\n</code></pre>",
	"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE":            "既に利用していた値の null チェック\n\n<p>\nここで値が <code>null</code> なのかチェックしていますが，既に値を利用していたので <code>null</code> である可能性はありません。\n値が <code>null</code> なら以前の利用で <code>NullPointerException</code> が発生していたでしょう。\n基本的に，値が <code>null</code> であることを許すのかどうかに関係なく，このコードと以前の値の利用は一致しません。\nチェックは冗長か，または以前の値の利用は誤りです。\n</p>",
	"RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE":                    "null とわかっている値の冗長な null チェック\n\n<p>\nこのメソッドには <code>null</code> とわかっている値の冗長な <code>null</code> チェックがあります。\n</p>",
	"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE":                 "null ではないことがわかっている値の冗長な null チェック\n\n<p>\nこのメソッドには <code>null</code> ではないことがわかっている値の冗長な <code>null</code> チェックがあります。\n</p>",
	"RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES":                 "2つの null 値の冗長な比較\n\n<p>\nこのメソッドには両方とも明らかに <code>null</code> とわかっている2つの参照の冗長な比較があります。\n</p>",
	"RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE":       "非 null 値と null 値との冗長な比較\n\n<p>\nこのメソッドには <code>null</code> ではないことがわかっている参照と <code>null</code> とわかっている別の参照との比較があります。\n</p>",
	"RCN_REDUNDANT_CHECKED_NULL_COMPARISON":                    "Redundant comparison to null of previously checked value\n\n<p> This method contains a redundant comparison of a reference value\nto null. Two types of redundant comparison are reported:\n</p>\n<ul>\n<li> Both values compared are definitely null</li>\n<li> One value is definitely null and the other is definitely not null</li>\n</ul>\n\n<p> This particular warning generally indicates that a\nvalue known not to be null was checked against null.\nWhile the check is not necessary, it may simply be a case\nof defensive programming.</p>",
	"UL_UNRELEASED_LOCK":                                       "すべての経路でロックが解除されないメソッド\n\n<p>\nこのメソッドは，JSR-166(java.util.concurrent) のロックを獲得していますが，メソッドからのすべての経路で解除していません。\n一般的に JSR-166 のロックを使用するための正しいイディオムは次のようになります。\n</p>\n<pre><code>Lock l = ...;\nl.lock();\ntry {\n    // do something\n} finally {\n    l.unlock();\n}\n</code></pre>",
	"UL_UNRELEASED_LOCK_EXCEPTION_PATH":                        "すべての例外経路でロックが解除されないメソッド\n\n<p>\nこのメソッドは，JSR-166(java.util.concurrent) のロックを獲得していますが，メソッドからのすべての例外経路で解除していません。\n一般的に JSR-166 のロックを使用するための正しいイディオムは次のようになります。\n</p>\n<pre><code>Lock l = ...;\nl.lock();\ntry {\n    // do something\n} finally {\n    l.unlock();\n}\n</code></pre>",
	"RC_REF_COMPARISON":                                        "疑わしい参照比較\n\n<p>\nこのメソッドは， <code>==</code> または <code>!=</code> 演算子を使用して2つの参照値を比較しています。\n一般的にこの型のインスタンスを比較する正しい方法は <code>equals</code> メソッドです。\n等価で識別可能なインスタンスを作成する可能性がありますが異なるオブジェクトなので <code>==</code> で比較しないでください。\n一般的に参照によって比較されるべきではないクラスの例は， <code>java.lang.Integer</code> ， <code>java.lang.Float</code> などです。\n</p>",
	"RC_REF_COMPARISON_BAD_PRACTICE":                           "定数の疑わしい参照比較\n\n<p>\nこのメソッドは，参照値を <code>==</code> または <code>!=</code> 演算子を使用して定数と比較しています。\n一般的にこの型のインスタンスを比較する正しい方法は <code>equals</code> メソッドです。\n等価で識別可能なインスタンスを作成する可能性がありますが異なるオブジェクトなので <code>==</code> で比較しないでください。\n一般的に参照によって比較されるべきではないクラスの例は， <code>java.lang.Integer</code> ， <code>java.lang.Float</code> などです。\n</p>",
	"RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN":                   "Boolean 値の疑わしい参照比較\n\n<p>\nこのメソッドは， <code>==</code> または <code>!=</code> 演算子を使用して2つの <code>Boolean</code> 値を比較しています。\n一般的には2つの <code>Boolean</code> 値 (<code>Boolean.TRUE</code> と <code>Boolean.FALSE</code>) だけですが，\n<code>new Boolean(b)</code> コンストラクタを使用して他の <code>Boolean</code> オブジェクトを作成する可能性があります。\nそのようなオブジェクトを回避することは最高です。\nしかし，それらが存在するなら， <code>Boolean</code> オブジェクトの等価性をチェックするために <code>.equals(...)</code> ではなく <code>==</code> または <code>!=</code> を使用しているなら異なる結果をもたらします。\n</p>",
	"EC_UNRELATED_TYPES_USING_POINTER_EQUALITY":                "参照等価性を使用して異なる型を比較している\n\n<p>\nこのメソッドは異なる型と思われる2つの参照を比較するために参照等価性を使用しています。\nこの比較の結果は，常に <code>false</code> です。\n</p>",
	"EC_UNRELATED_TYPES":                                       "equals メソッドを呼び出して異なる型を比較している\n\n<p>\nこのメソッドは，異なるクラス型の2つの参照で <code>equals(Object)</code> メソッドを呼び出していて，解析が実行時に異なるクラスのオブジェクトになることを示唆しています。\nさらに，呼び出されるであろう <code>equals</code> メソッドの検査では，この呼び出しは常に <code>false</code> を返します。\nあるいは， <code>equals</code> メソッドが対称 (<code>Object</code> クラスの <code>equals</code> のための契約に必要な性質) ではないことのどちらかを示唆しています。\n</p>",
	"EC_UNRELATED_INTERFACES":                                  "equals メソッドを呼び出して異なる型のインタフェースを比較している\n\n<p>\nこのメソッドは，どちらも他方のサブタイプではない無関係なインタフェース型の2つの参照で <code>equals(Object)</code> メソッドを呼び出しています。\nそして，両方のインタフェースを実装する既知の非抽象クラスがありません。\nしたがって比較されている2つのオブジェクトは実行時に同じクラスのメンバである可能性が低いです (いくつかのアプリケーションクラスが解析できなかったか，動的クラスローディングが実行時に起こることができた場合を除く)。\n<code>equals</code> メソッドの規約によると，異なるクラスのオブジェクトは常に等しくないとして比較すべきです。\nしたがって， <code>java.lang.Object.equals(Object)</code> によって定義される規約によれば，この比較の結果は実行時に常に <code>false</code> になります。\n</p>",
	"EC_UNRELATED_CLASS_AND_INTERFACE":                         "equals メソッドを呼び出して無関係のクラスとインタフェースを比較している\n\n<p>\nこのメソッドは，一方がクラスで他方がインタフェースである2つの参照で <code>equals(Object)</code> メソッドを呼び出しています。\nクラスは，そのクラスの非抽象サブクラスも含めてインタフェースを実装していません。\nしたがって比較されている2つのオブジェクトは実行時に同じクラスのメンバである可能性が低いです (いくつかのアプリケーションクラスが解析できなかったか，動的クラスローディングが実行時に起こることができた場合を除く)。\n<code>equals</code> メソッドの規約によると，異なるクラスのオブジェクトは常に等しくないとして比較すべきです。\nしたがって， <code>java.lang.Object.equals(Object)</code> によって定義される規約によれば，この比較の結果は実行時に常に <code>false</code> になります。\n</p>",
	"EC_NULL_ARG":                                              "equals(null) の呼び出し\n\n<p>\nこのメソッドは， <code>null</code> 値の引数を渡して <code>equals(Object)</code> を呼び出しています。\n<code>equals</code> メソッドの規約によると，この呼び出しは常に <code>false</code> を返すはずです。\n</p>",
	"MWN_MISMATCHED_WAIT":                                      "不整合な wait メソッド\n\n<p>\nこのメソッドは，オブジェクトで明らかにロックを保持することなく， <code>Object.wait()</code> を呼び出しています。\n保持されるロックがない状態で， <code>wait</code> メソッドを呼び出すことは， <code>IllegalMonitorStateException</code> をスローすることになります。\n</p>",
	"MWN_MISMATCHED_NOTIFY":                                    "不整合な notify メソッド\n\n<p>\nこのメソッドは，オブジェクトで明らかにロックを保持することなく <code>Object.notify()</code> や <code>Object.notifyAll()</code> を呼び出しています。\n保持されるロックがない状態で， <code>notify</code> メソッドや <code>notifyAll</code> メソッドを呼び出すことは， <code>IllegalMonitorStateException</code> をスローすることになります。\n</p>",
	"SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD":                "フィールドへの代入ではなくローカル変数への自己代入\n\n<p>\nこのメソッドにはローカル変数の自己代入があり，ローカル変数とフィールドが同じ名前です。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>    int foo;\n    public void setFoo(int foo) {\n        foo = foo;\n    }\n</code></pre>\n<p>\nそのような代入は役に立ちません。そうではなく，フィールドに代入するつもりでしたか？\n</p>",
	"SA_LOCAL_SELF_ASSIGNMENT":                                 "ローカル変数の自己代入\n\n<p>\nこのメソッドにはローカル変数の自己代入があります。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>public void foo() {\n    int x = 3;\n    x = x;\n}\n</code></pre>\n<p>\nそのような代入は役に立たないので，論理エラーかタイプミスかもしれません。\n</p>",
	"SA_FIELD_SELF_ASSIGNMENT":                                 "フィールドの自己代入\n\n<p>\nこのメソッドにはフィールドの自己代入があります。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>int x;\npublic void foo() {\n    x = x;\n}\n</code></pre>\n<p>\nそのような代入は役に立たないので，論理エラーかタイプミスかもしれません。\n</p>",
	"SA_FIELD_DOUBLE_ASSIGNMENT":                               "フィールドの二重代入\n\n<p>\nこのメソッドにはフィールドの二重代入があります。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>int x,y;\npublic void foo() {\n    x = x = 17;\n}\n</code></pre>\n<p>\nフィールドに2回代入することは役に立たないので，論理エラーかタイプミスかもしれません。\n</p>",
	"SA_LOCAL_DOUBLE_ASSIGNMENT":                               "ローカル変数の二重代入\n\n<p>\nこのメソッドにはローカル変数の二重代入があります。<br>\nたとえば次のようなコードです。\n</p>\n<pre><code>public void foo() {\n    int x,y;\n    x = x = 17;\n}\n</code></pre>\n<p>\n変数に同じ値を2回代入することは役に立たないので，論理エラーかタイプミスかもしれません。\n</p>",
	"SA_FIELD_SELF_COMPUTATION":                                "フィールドの無意味な自己演算 (たとえば，x & x)\n\n<p>\nこのメソッドは，フィールドと同じフィールドへの別の参照との無意味な計算を実行しています (たとえば， <code>x &amp; x</code> または <code>x - x</code>)。\nこの計算の性質のため，演算は意味をなすとは思われないので，論理エラーかタイプミスかもしれません。\n計算をチェックしてください。\n</p>",
	"SA_LOCAL_SELF_COMPUTATION":                                "変数の無意味な自己演算 (たとえば，x & x)\n\n<p>\nこのメソッドは，ローカル変数と同じ変数への別の参照との無意味な計算を実行しています (たとえば， <code>x &amp; x</code> または <code>x - x</code>)。\nこの計算の性質のため，演算は意味をなすとは思われないので，論理エラーかタイプミスかもしれません。\n計算をダブルチェックしてください。\n</p>",
	"SA_FIELD_SELF_COMPARISON":                                 "フィールドとそれ自身との自己比較\n\n<p>\nこのメソッドは，フィールドをそれ自身と比較しています。論理エラーかタイプミスかもしれません。\n正しいものを比較していることを確認してください。\n</p>",
	"SA_LOCAL_SELF_COMPARISON":                                 "ローカル変数とそれ自身との自己比較\n\n<p>\nこのメソッドは，ローカル変数をそれ自身と比較しています。論理エラーかタイプミスかもしれません。\n正しいものを比較していることを確認してください。\n</p>",
	"DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT":                   "int に対して Double.longBitsToDouble() を呼び出している\n\n<p>\n<code>Double.longBitsToDouble()</code> の呼び出しで，32ビット int 値が引数として渡されています。\nこれはほぼ間違いなく意図したことではなく，意図した結果を出す可能性は低いです。\n</p>",
	"DMI_ARGUMENTS_WRONG_ORDER":                                "逆にされたメソッド引数\n\n<p>\nこのメソッド呼び出しへの引数は，順序が間違っているように見えます。\nたとえば，呼び出し <code>Preconditions.checkNotNull(\"message\", message)</code> は，引数を予約しました。チェックされる値は第一引数です。\n</p>",
	"DMI_RANDOM_USED_ONLY_ONCE":                                "Random オブジェクトが作成され1度しか使われない\n\n<p>\nこのコードは <code>java.util.Random</code> オブジェクトを作成して1つの乱数を生成するために使用して捨てています。\nこれはあまり良くない品質の乱数を作り出し，効率が悪いです。\nできれば， <code>Random</code> オブジェクトを1つだけ作成して保存されるようにコードを書き直してください。\nそして，毎回新しい乱数は既存の <code>Random</code> オブジェクトを呼び出して取得することが必要です。\n</p>\n<p>\n生成された乱数が推測可能ではないことが重要なら，乱数ごとに新しい <code>Random</code> オブジェクトを作成してはいけません (値はあまりに簡単に推測可能です)。\nその代わりに <code>java.security.SecureRandom</code> の使用を強く検討すべきです (そして必要とされる乱数ごとに新しい <code>SecureRandom</code> のオブジェクトを作成することを回避します)。\n</p>",
	"RV_ABSOLUTE_VALUE_OF_RANDOM_INT":                          "符号付き整数の乱数の絶対値を計算する間違った試み\n\n<p>\nこのコードは符号付き整数の乱数を生成して絶対値を計算しています。\n乱数ジェネレータで返される数が <code>Integer.MIN_VALUE</code> なら結果は同様に負です (<code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code> なので)。\n(同じ問題は <code>long</code> 値でも同様に起きます)。\n</p>",
	"RV_ABSOLUTE_VALUE_OF_HASHCODE":                            "符号付き32ビットハッシュコードの絶対値を計算する間違った試み\n\n<p>\nこのコードはハッシュコードを生成して絶対値を計算しています。\nハッシュコードが <code>Integer.MIN_VALUE</code> なら結果は同様に負です (<code>Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE</code> なので)。\n</p>\n<p>\n文字列の2^32個に1個は <code>Integer.MIN_VALUE</code> のハッシュコードを持っていて，「polygenelubricants」，「GydZG_」，「DESIGNING WORKHOUSES」が該当します。\n</p>",
	"RV_REM_OF_RANDOM_INT":                                     "符号付き32ビット整数の乱数の剰余\n\n<p>\nこのコードは符号付き整数の乱数を生成して別の値を法とする剰余を計算しています。\n乱数は負になり，剰余演算の結果も負になります。これが意図したことであることを確実にしてください。\nその代わりに <code>Random.nextInt(int)</code> の使用を強く検討してください。\n</p>",
	"RV_REM_OF_HASHCODE":                                       "ハッシュコードの剰余は負かもしれない\n\n<p>\nこのコードはハッシュコードを計算して別の値を法とする剰余を計算しています。\nハッシュコードは負になり，剰余演算の結果も負なります。\n</p>\n<p>\n計算結果が負ではないことを確認したいなら，コードを変更する必要があるかもしれません。\n除数が2の累乗であることがわかっているなら，代わりにビット演算を使用できます (すなわち， <code>x.hashCode()%n</code> の代わりに <code>x.hashCode()&amp;(n-1)</code> を使用してください)。\nこれはおそらく，剰余を計算するより高速です。\n除数が2の累乗であるということをわかっていないなら，剰余演算の結果の絶対値を取得してください (すなわち <code>Math.abs(x.hashCode()%n)</code>)。\n</p>",
	"INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE":                "負ではない値と負の定数またはゼロとの間違った比較\n\n<p>\nこのコードは負ではないことが保証されている値と負の定数またはゼロとを比較しています。\n</p>",
	"INT_BAD_COMPARISON_WITH_SIGNED_BYTE":                      "符号付きバイトの間違った比較\n\n<p>\n符号付バイトのとりうる値の範囲は-128～127です。その範囲外で符号付バイトを値と比較することは無意味で間違っていそうです。\n符号付きバイト <code>b</code> を範囲が0～255の符号なしバイトに変換するには <code>0xff &amp; b</code> を使用してください。\n</p>",
	"INT_BAD_COMPARISON_WITH_INT_VALUE":                        "int 値と long 定数との間違った比較\n\n<p>\nこのコードはint 値と int 値として表される値の範囲外の long 定数を比較しています。\nこの比較は無意味で，おそらく間違っています。\n</p>",
	"INT_VACUOUS_BIT_OPERATION":                                "整数値の無意味なビットマスク演算\n\n<p>\nどんな有用な仕事もしない整数ビット演算 (AND，OR，XOR) です (たとえば <code>v &amp; 0xffffffff</code>)。\n</p>",
	"INT_VACUOUS_COMPARISON":                                   "整数値の無意味な比較\n\n<p>\n常に同じ値を返す整数の比較があります (たとえば <code>x &lt;= Integer.MAX_VALUE</code>)。\n</p>",
	"INT_BAD_REM_BY_1":                                         "1を法とする整数の剰余\n\n<p>\nどんな式 <code>(exp % 1)</code> も常に0を返すことが保証されています。\nそうではなく， <code>(exp &amp; 1)</code> または <code>(exp % 2)</code> を意味していましたか？\n</p>",
	"BIT_IOR_OF_SIGNED_BYTE":                                   "符号付きバイト値のビット論理和\n\n<p>\nロードしたバイト値 (たとえば，バイト配列からロードされた値や戻り値がバイト型のメソッドから返された値) とビット論理和を実行しています。\nビット演算を実行する前にバイト値は32ビットまで符号拡張されます。\nしたがって， <code>b[0]</code> の値が <code>0xff</code> で， <code>x</code> の初期値が <code>0</code> だとすると，\n<code>((x &lt;&lt; 8) | b[0])</code> は， <code>0xff</code> が符号拡張で <code>0xffffffff</code> になるので，結果として <code>0xffffffff</code> が得られます。\n</p>\n<p>\n特に，バイト配列を <code>int</code> にパックする次のようなコードはひどく間違っています。\n</p>\n<pre><code>int result = 0;\nfor(int i = 0; i &lt; 4; i++) {\n    result = ((result &lt;&lt; 8) | b[i]);\n}\n</code></pre>\n<p>\nその代わりに次のようなイディオムは動作します。\n</p>\n<pre><code>int result = 0;\nfor(int i = 0; i &lt; 4; i++) {\n    result = ((result &lt;&lt; 8) | (b[i] &amp; 0xff));\n}\n</code></pre>",
	"BIT_ADD_OF_SIGNED_BYTE":                                   "符号付きバイト値のビット加算\n\n<p>\nバイト値と明らかに下位8ビットがあるとわかっている値を加算しています。\nビット演算を実行する前にバイト配列からロードされた値は32ビットまで符号拡張されます。\nしたがって， <code>b[0]</code> の値が <code>0xff</code> で， <code>x</code> の初期値が <code>0</code> だとすると，\n<code>((x &lt;&lt; 8) + b[0])</code> は， <code>0xff</code> が符号拡張で <code>0xffffffff</code> になるので，結果として <code>0xffffffff</code> が得られます。\n</p>\n<p>\n特に，バイト配列を <code>int</code> にパックする次のようなコードはひどく間違っています。\n</p>\n<pre><code>int result = 0;\nfor(int i = 0; i &lt; 4; i++)\n    result = ((result &lt;&lt; 8) + b[i]);\n</code></pre>\n<p>\nその代わりに次のようなイディオムは動作します。\n</p>\n<pre><code>int result = 0;\nfor(int i = 0; i &lt; 4; i++)\n    result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));\n</code></pre>",
	"BIT_AND":                                                  "互換性のないビットマスク\n\n<p>\nこのメソッドは， <code>(e &amp; C)</code> 形式の式を <code>D</code> と比較しています。\n定数 <code>C</code> の特定の値と <code>D</code> ために常に等しくないことを比較します。論理エラーかタイプミスかもしれません。\n</p>",
	"BIT_SIGNED_CHECK":                                         "ビット演算の符号をチェックする\n\n<p>\nこのメソッドは， <code>((event.detail &amp; SWT.SELECTED) &gt; 0)</code> のような式で比較しています。\nビット演算をより大きい演算子で比較することは，予想外の結果 (もちろん， <code>SWT.SELECTED</code> の値による) の原因になる可能性があります。\n<code>SWT.SELECTED</code> が負数であるなら，これはバグの候補です。\n<code>SWT.SELECTED</code> が負ではないとしても， <code>&gt; 0</code> の代わりに <code>!= 0</code> を使用することが良いプラクティスであると思われます。\n</p>",
	"BIT_SIGNED_CHECK_HIGH_BIT":                                "負数を含むビット演算の符号をチェックする\n\n<p>\nこのメソッドは， <code>CONSTANT</code> が負数のときに <code>((val &amp; CONSTANT) &gt; 0)</code> のようなビット演算式で比較しています。\nビット演算をより大きい演算子で比較することは，予想外の結果の原因になる可能性があります。比較は期待したようになりません。\n<code>&gt; 0</code> の代わりに <code>!= 0</code> を使用することが良いプラクティスです。\n</p>",
	"BIT_AND_ZZ":                                               "((...) & 0) == 0 なのか確かめている\n\n<p>\nこのメソッドは， <code>(e &amp; 0)</code> 形式の式を0と比較しています。それは，常に等価であることを比較します。論理エラーかタイプミスかもしれません。\n</p>",
	"BIT_IOR":                                                  "互換性のないビットマスク\n\n<p>\nこのメソッドは， <code>(e | C)</code> 形式の式を <code>D</code> と比較しています。\n定数 <code>C</code> と <code>D</code> の特定の値のために常に等しくないことを比較します。論理エラーかタイプミスかもしれません。\n</p>\n<p>\n通常，このバグは，ビットセットで帰属関係のテストを実行したいコードで発生します。\nしかし，ビット論理積演算子 (<code>&amp;</code>) の代わりにビット論理和演算子 (<code>|</code>) を使用しています。\n</p>\n<p>\nこうしたバグは <code>(e &amp; (A | B)) == C</code> が意図されている間に <code>((e &amp; A) | B) == C</code> のように解析される <code>(e &amp; A | B) == C</code> のような式で現れるかもしれません。\n</p>",
	"LI_LAZY_INIT_INSTANCE":                                    "Incorrect lazy initialization of instance field\n\n<p> This method contains an unsynchronized lazy initialization of a non-volatile field.\nBecause the compiler or processor may reorder instructions,\nthreads are not guaranteed to see a completely initialized object,\n<em>if the method can be called by multiple threads</em>.\nYou can make the field volatile to correct the problem.\nFor more information, see the\n<a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\">Java Memory Model web site</a>.\n</p>",
	"LI_LAZY_INIT_STATIC":                                      "static フィールドの間違った遅延初期化\n\n<p>\nこのメソッドには <code>volatile</code> ではない <code>static</code> フィールドの非同期な遅延初期化があります。\nコンパイラやプロセッサが命令を並べ替えるかもしれないので，メソッドが複数のスレッドによって呼び出されるなら，スレッドは完全に初期化されたオブジェクトを参照することは保証されません。\nこの問題を修正するためにフィールドを <code>volatile</code> にできます。<br>\n詳細は， <a href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/\">Java Memory Model web site</a> を参照してください。\n</p>",
	"LI_LAZY_INIT_UPDATE_STATIC":                               "更新される static フィールドの間違った遅延初期化\n\n<p>\nこのメソッドには <code>static</code> フィールドの非同期な遅延初期化があります。\nフィールドが設定されると，その場所に格納されているオブジェクトはさらに更新またはアクセスされます。フィールドの設定は，他のスレッドにすぐに見えます。\nフィールドを設定するメソッドのさらなるアクセスがオブジェクトの初期化に役立つなら，\n完全に初期化されるまで他のスレッドが格納されたオブジェクトにアクセスすることを防がないかぎり，非常に深刻なマルチスレッドバグがあります。\n</p>\n<p>\nたとえメソッドが複数のスレッドによって決して呼び出されないと確信していても，\nフィールドに設定する値が完全に設定/初期化されるまで， <code>static</code> フィールドを設定しないほうが良いかもしれません。\n</p>",
	"JLM_JSR166_LOCK_MONITORENTER":                             "Lock で同期化している\n\n<p>\nこのメソッドは， <code>java.util.concurrent.locks.Lock</code> を実装したオブジェクトで同期化しています。\nそのようなオブジェクトは <code>synchronized (...)</code> 構文よりも <code>acquire()</code>/<code>release()</code> を使用してロックとロックの解除をします。\n</p>",
	"JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT":                "util.concurrent 抽象化でモニタスタイルの wait メソッドを使用している\n\n<p>\nこのメソッドは， <code>await()</code> メソッド， <code>signal</code> メソッド， <code>signalAll</code> メソッドを提供するオブジェクト\n(たとえば，util.concurrent の <code>Condition</code> オブジェクト) で， <code>wait</code> メソッド， <code>notify</code> メソッド， <code>notifyAll</code> メソッドを呼び出しています。\nこれはおそらくあなたが望むことではなく，たとえそれを望むとしても，他の開発者が非常に混乱することを理解して，設計を変更することを検討すべきです。\n</p>",
	"JLM_JSR166_UTILCONCURRENT_MONITORENTER":                   "java.util.concurrent のインスタンスで同期化している\n\n<p>\nこのメソッドは，java.util.concurrent パッケージのクラス (またはサブクラス) のインスタンスで同期化しています。\nこれらのクラスのインスタンスは， <code>synchronized</code> による同期とは違う独自の並行制御メカニズムを持っています。\nたとえば， <code>AtomicBoolean</code> で同期しても，他のスレッドが <code>AtomicBoolean</code> を変更することを防げません。\n</p>\n<p>\nそのようなコードは正しいかもしれませんが，将来コードを維持しなければならない人々を混乱させるかもしれないので慎重にレビューし文書化すべきです，\n</p>",
	"UPM_UNCALLED_PRIVATE_METHOD":                              "private メソッドは決して呼び出されない\n\n<p>\nこの <code>private</code> メソッドは，決して呼び出されません。\nメソッドがリフレクションによって呼び出されるかもしれないが，決して使われないなら除去すべきです。\n</p>",
	"UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS":                "呼び出し不可能なメソッドが無名クラスで定義されている\n\n<p>\nこの無名クラスは，直接呼び出されないスーパークラスのメソッドをオーバーライドしていないメソッドを定義しています。\n他のクラスのメソッドが無名クラスで宣言されたメソッドを直接呼び出せないので，このメソッドは呼び出し不可能だと思われます。\nメソッドは単にデッドコードであるかもしれません。しかし，メソッドがスーパークラスで宣言されるメソッドをオーバーライドすることを意図した可能性もあります。\nそして，タイプミスまたは他の誤りのためにメソッドは，実際には意図しているメソッドをオーバーライドしません。\n</p>",
	"ODR_OPEN_DATABASE_RESOURCE":                               "データベースリソースのクローズに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，データベースリソース (たとえば，データベースコネクションや行セット) を作成していますが，どんなフィールドにも代入していないか，他のメソッドにも渡していないか，戻り値にもしていません。\nそして，メソッドからのすべての経路でオブジェクトをクローズするように見えません。\nメソッドからのすべての経路でデータベースリソースのクローズが失敗すると性能低下になることがあります。\nデータベースとの通信で問題があるアプリケーションの原因になる可能性があります。\n</p>",
	"ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH":                "例外経路でデータベースリソースのクローズに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，データベースリソース (たとえば，データベースコネクションや行セット) を作成していますが，どんなフィールドにも代入していないか，他のメソッドにも渡していないか，戻り値にもしていません。\nそして，メソッドからのすべての例外経路でオブジェクトをクローズするように見えません。\nメソッドからのすべての経路でデータベースリソースのクローズが失敗すると性能低下になることがあります。\nデータベースとの通信で問題があるアプリケーションの原因になる可能性があります。\n</p>",
	"SBSC_USE_STRINGBUFFER_CONCATENATION":                      "ループの中で + を使用して文字列を連結しているメソッド\n\n<p>\nこのメソッドは，ループの中で + を使用して <code>String</code> を構築していると思われます。\n各々の繰り返しにおいて， <code>String</code> は <code>StringBuffer</code>/<code>StringBuilder</code> に変換，追加され， <code>String</code> へ変換されます。\n各々の繰り返しで文字列が再コピーされ，増大すると繰り返しの数で二次コストの原因になる可能性があります。\n</p>\n<p>\n<code>StringBuffer</code> (または J2SE 5.0の <code>StringBuilder</code>) を明示的に使うとより良い性能を得られます。\n</p>\n<p>\nたとえば，\n</p>\n<pre><code>// This is bad\nString s = \"\";\nfor (int i = 0; i &lt; field.length; ++i) {\n    s = s + field[i];\n}\n\n// This is better\nStringBuffer buf = new StringBuffer();\nfor (int i = 0; i &lt; field.length; ++i) {\n    buf.append(field[i]);\n}\nString s = buf.toString();\n</code></pre>",
	"IIL_PREPARE_STATEMENT_IN_LOOP":                            "ループの中で prepareStatement を呼び出しているメソッド\n\n<p>\nメソッドは，ループの中で <code>Connection.prepareStatement</code> に不変の引数を渡して呼び出しています。\n<code>PreparedStatement</code> を複数回実行する必要があるなら，それぞれのループの繰り返しで再生成する理由がありません。\nループの外に呼び出しを移動します。\n</p>",
	"IIL_ELEMENTS_GET_LENGTH_IN_LOOP":                          "ループの中で NodeList.getLength() を呼び出しているメソッド\n\n<p>\nメソッドは，ループの中で <code>NodeList.getLength()</code> を呼び出し， <code>NodeList</code> は， <code>getElementsByTagName</code> の呼び出しによって作られます。\n<code>NodeList</code> は長さを格納しませんが，毎回とても最適ではない方法で計算されます。\nループの前に変数に長さを格納することを検討してください。\n</p>",
	"IIL_PATTERN_COMPILE_IN_LOOP":                              "ループの中で Pattern.compile を呼び出しているメソッド\n\n<p>\nメソッドは，ループの中で <code>Pattern.compile</code> に不変の定数を渡して呼び出しています。\n<code>Pattern</code> を複数回使用する必要があるなら，それぞれのループの繰り返しでコンパイルする理由がありません。\nループの外に呼び出しを移動するか <code>static final</code> フィールドにします。\n</p>",
	"IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT":                     "ループの中で正規表現をコンパイルしているメソッド\n\n<p>\nメソッドは，ループの中で同じ正規表現を生成しているので，繰り返しごとにコンパイルされます。\nループの外で <code>Pattern.compile</code> を使用して正規表現をプリコンパイルするのが最適でしょう。\n</p>",
	"IIO_INEFFICIENT_INDEX_OF":                                 "String.indexOf(String) の非効率的な使用\n\n<p>\nこのコードは <code>String.indexOf()</code> に長さ1の文字列定数を渡しています。<code>String.indexOf()</code> の整数実装を使うほうが効率的です。\nたとえば， <code>myString.indexOf(\".\")</code> の代わりに <code>myString.indexOf('.')</code> を呼び出します。\n</p>",
	"IIO_INEFFICIENT_LAST_INDEX_OF":                            "String.lastIndexOf(String) の非効率的な使用\n\n<p>\nこのコードは <code>String.lastIndexOf()</code> に長さ1の文字列定数を渡しています。<code>String.lastIndexOf()</code> の整数実装を使うほうが効率的です。\nたとえば， <code>myString.lastIndexOf(\".\")</code> の代わりに <code>myString.lastIndexOf('.')</code> を呼び出します。\n</p>",
	"ITA_INEFFICIENT_TO_ARRAY":                                 "長さが0の配列の引数で toArray メソッドを使用しているメソッド\n\n<p>\nこのメソッドは， <code>Collection</code> 派生クラスの </code>toArray</code> メソッドを使用して長さが0の配列の引数を渡しています。\n<code>myCollection.toArray(new Foo[myCollection.size()])</code> を使用するほうがより効率的です。\n渡される配列がコレクションの要素のすべてを格納できるくらいの大きさなら，設定されて，そのまま返されます。\nこれは結果として返す2番目の配列 (リフレクションによって) を作成する必要を回避します。\n</p>",
	"IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD":                "run メソッドでの JUnit アサーションは JUnit によって通知されない\n\n<p>\n<code>run</code> メソッドで JUnit アサーションが実行されています。失敗した JUnit アサーションは例外をスローします。\nしたがって，この例外がテストメソッドを実行したスレッド以外のスレッドで発生するなら，例外はスレッドを終了させますが，テストの失敗になりません。\n</p>",
	"IJU_SETUP_NO_SUPER":                                       "TestCase は super.setup() を呼び出さない setUp メソッドを実装している\n\n<p>\nJUnit の <code>TestCase</code> クラスで， <code>setUp</code> メソッドを実装しています。\n<code>setUp</code> メソッドは， <code>super.setUp()</code> を呼び出すべきなのにそうしていません。\n</p>",
	"IJU_TEARDOWN_NO_SUPER":                                    "TestCase は super.tearDown() を呼び出さない tearDown メソッドを実装している \n\n<p>\nJUnit の <code>TestCase</code> クラスで， <code>tearDown</code> メソッドを実装しています。\n<code>tearDown</code> メソッドは， <code>super.tearDown()</code> を呼び出すべきなのにそうしていません。\n </p>",
	"IJU_SUITE_NOT_STATIC":                                     "TestCase は 非 static な suite メソッドを実装している\n\n<p>\nJUnit の <code>TestCase</code> クラスで， <code>suite</code> メソッドを実装しています。\n<code>suite</code> メソッドは <code>static</code> として宣言すべきなのにそうしていません。\n</p>",
	"IJU_BAD_SUITE_METHOD":                                     "TestCase は suite メソッドの間違った宣言をしている\n\n<p>\nJUnit の <code>TestCase</code> クラスで， <code>suite</code> メソッドを実装しています。\nしかしながら， <code>suite</code> メソッドは，\n</p>\n<pre><code>public static junit.framework.Test suite()\n</code></pre>\n<p>か</p>\n<pre><code>public static junit.framework.TestSuite suite()\n</code></pre>\n<p>\nのどちらかを宣言する必要があります。\n</p>",
	"IJU_NO_TESTS":                                             "TestCase はテストがない \n\n<p>\nJUnit の <code>TestCase</code> クラスで，どんなテストメソッドも実装していません。\n</p>",
	"BOA_BADLY_OVERRIDDEN_ADAPTER":                             "スーパークラスの Adapter で実装されるメソッドを誤ってオーバーライドしているクラス\n\n<p>\nこのメソッドは，スーパークラスで実装されているメソッドをオーバーライドしています。\nスーパークラスは，java.awt.event や javax.swing.event パッケージで定義されているリスナを実装する <code>Adapter</code> です。\nその結果，イベントが発生するときこのメソッドは呼び出されません。\n</p>",
	"BRSA_BAD_RESULTSET_ACCESS":                                "Method attempts to access a result set field with index 0\n\n<p> A call to getXXX or updateXXX methods of a result set was made where the\nfield index is 0. As ResultSet fields start at index 1, this is always a mistake.</p>",
	"SQL_BAD_RESULTSET_ACCESS":                                 "インデックスが0で ResultSet にアクセスしようとしているメソッド\n\n<p>\nインデックスが0で， <code>ResultSet</code> の <code>getXXX</code> ， <code>updateXXX</code> メソッドを呼び出しています。\n<code>ResultSet</code> のインデックスは1から開始するので，これは常に間違いです。\n</p>",
	"SQL_BAD_PREPARED_STATEMENT_ACCESS":                        "インデックスが0で PreparedStatement にアクセスしようとしているメソッド\n\n<p>\nインデックスが0で， <code>PreparedStatement</code> の <code>setXXX</code> メソッドを呼び出しています。\nインデックスは1から開始するので，これは常に間違いです。\n</p>",
	"SIO_SUPERFLUOUS_INSTANCEOF":                               "instanceof 演算子を使用した不必要な型チェック\n\n<p>\nオブジェクトが要求する型であるかどうかにかかわらず，静的に判定される <code>instanceof</code> 演算子を使用して型チェックをしています。\n</p>",
	"BAC_BAD_APPLET_CONSTRUCTOR":                               "初期化されていない AppletStub に依存する間違ったアプレットコンストラクタ\n\n<p>\nこのコンストラクタは， <code>AppletStub</code> に依存する親アプレットでメソッドを呼び出しています。\nこのアプレットの <code>init</code> メソッドが呼び出されるまで <code>AppletStub</code> は初期化されないので，これらのメソッドは正しく機能しません。\n</p>",
	"EC_ARRAY_AND_NONARRAY":                                    "equals メソッドを使用して配列と非配列を比較している\n\n<p>\nこのメソッドは，配列と配列だと思われない参照を比較するために <code>.equals(Object o)</code> を呼び出しています。\n比較されているものが違う型なら等しくないことであることが保証されているので，比較はほぼ間違いなく誤りです。\nたとえそれらが両方とも配列だったとしても，配列の <code>equals</code> メソッドは2つの配列が同じオブジェクトだと決定するだけです。\n配列の内容を比較するためには <code>java.util.Arrays.equals(Object[], Object[])</code> を使用してください。\n</p>",
	"EC_BAD_ARRAY_COMPARE":                                     "配列の equals メソッド呼び出しは == と等価である\n\n<p>\nこのメソッドは，配列で <code>.equals(Object o)</code> を呼び出しています。\n配列は， <code>Object</code> の <code>equals</code> メソッドをオーバーライドしないので，配列で <code>equals</code> メソッドを呼び出すことはアドレスを比較することと同じです。\n配列の内容を比較するためには <code>java.util.Arrays.equals(Object[], Object[])</code> を使用してください。\n配列のアドレスを比較するために明示的に <code>==</code> を使用して参照等価性をチェックすることは，それほど紛らわしくないでしょう。\n</p>",
	"EC_INCOMPATIBLE_ARRAY_COMPARE":                            "equals(...) メソッドを使用して互換性のない配列を比較している\n\n<p>\nこのメソッドは，互換性のない型の配列を比較するために <code>.equals(Object o)</code> を呼び出しています (たとえば， <code>String[]</code> と <code>StringBuffer[]</code> ， <code>String[]</code> と <code>int[]</code>) 。\nそれらは，決して等価ではありません。\nさらに， <code>equals(...)</code> を使用してが配列を比較すると，同じ配列なのか確かめるだけで，配列の内容は無視されます。\n</p>",
	"STI_INTERRUPTED_ON_CURRENTTHREAD":                         "interrupted メソッドを呼び出すために不要な currentThread メソッドを呼び出している\n\n<p>\nこのメソッドは， <code>interrupted</code> メソッドを呼び出すために <code>Thread.currentThread()</code> を呼び出しています。\n<code>interrupted</code> メソッドは <code>static</code> メソッドなので， <code>Thread.interrupted()</code> を使用するほうが単純明解です。\n</p>",
	"STI_INTERRUPTED_ON_UNKNOWNTHREAD":                         "スレッドインスタンスで static Thread.interrupted() を呼び出している\n\n<p>\nこのメソッドは，カレントスレッドではない <code>Thread</code> オブジェクトであるように見える <code>Thread</code> オブジェクトで <code>Thread.interrupted()</code> を呼び出しています。\n<code>interrupted</code> メソッドは <code>static</code> なので，作成者が意図したこととは異なるオブジェクトで呼び出されます。\n</p>",
	"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN":                     "メソッドで読み取られずに上書きされているパラメータ\n\n<p>\nこのパラメータの初期値は無視され，ここで上書きされています。\nこれは多くの場合，パラメータへの書き込みが呼び出し元に戻されるという誤った考えを示しています。\n</p>",
	"DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD":                       "フィールドを遮るローカル変数への無効な代入\n\n<p>\nこの命令は，ローカル変数に値を代入していますが，値は読み出されないか以降の命令でも使われません。\n多くの場合，計算された値が決して使われないので，これは誤りを示します。\nフィールドがローカル変数と同じ名前です。そうではなく，フィールドに代入するつもりでしたか？\n</p>",
	"DLS_DEAD_LOCAL_STORE":                                     "ローカル変数への無効な代入\n\n<p>\nこの命令はローカル変数に値を代入していますが，値は読み出されないか以降の命令でも使われません。\n多くの場合，計算された値が決して使われないので，これは誤りを示します。\n</p>\n<p>\nSun の javac コンパイラが <code>final</code> なローカル変数のためにしばしば無効な格納を生成することに注意してください。\nSpotBugs は，バイトコードベースのツールなので誤検出をなくす簡単な方法がありません。\n</p>",
	"DLS_DEAD_LOCAL_STORE_IN_RETURN":                           "return 文に役に立たない代入がある\n\n<p>\nこの文は， <code>return</code> 文でローカル変数に代入をしています。この代入は効果がありません。\nこの文が正しいことを確かめてください。\n</p>",
	"DLS_DEAD_LOCAL_INCREMENT_IN_RETURN":                       "return 文に無駄なインクリメントがある\n\n<p>\n<code>return x++;</code> のような <code>return</code> 文があります。\n接頭辞インクリメント/デクリメントは 式の値に影響を与えないので，インクリメント/デクリメントは効果がありません。\nこの文が正しいことを確かめてください。\n</p>",
	"DLS_DEAD_STORE_OF_CLASS_LITERAL":                          "クラスリテラルの無効な代入\n\n<p>\nこの命令は変数にクラスリテラルを代入していますが，決して使われません。<br>\n<a href=\"http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal\">The behavior of this differs in Java 1.4 and in Java 5</a><br>\nJ2SE 1.4 およびそれ以前のバージョンでは， <code>Foo.class</code> への参照は <code>Foo</code> のためのスタティックイニシャライザが既に実行されていないなら実行することを強制します。\nJ2SE 5.0 ではそうしません。\n</p>\n<p>\nより多くの詳細と例と J2SE 5.0 のクラスの強制的な初期化の方法の提案は Sun の <a href=\"http://www.oracle.com/technetwork/java/javase/compatibility-137462.html#literal\">article on Java SE compatibility</a> を参照してください。\n</p>",
	"DLS_DEAD_LOCAL_STORE_OF_NULL":                             "ローカル変数への無効な null 代入\n\n<p>\nこのコードはローカル変数に <code>null</code> を代入していますが代入された値は読み出されていません。\nこの代入はガベージコレクタを手伝うために導入されたのかもしれませんが，Java SE 6 ではもはや必要とされないか有用ではありません。\n</p>",
	"MF_METHOD_MASKS_FIELD":                                    "フィールドを隠す変数を定義しているメソッド\n\n<p>\nこのメソッドは，このクラスまたはスーパークラスのフィールドと同じ名前でローカル変数を定義しています。\nフィールドから初期化されていない値を読み出す，初期化されていないフィールドをそのままにしておくか，または両方を引き起こすかもしれません。\n</p>",
	"MF_CLASS_MASKS_FIELD":                                     "スーパークラスのフィールドを隠すフィールドを定義しているクラス\n\n<p>\nこのクラスは，スーパークラスの可視インスタンスフィールドと同じ名前でフィールドを定義しています。\nこれは紛らわしくて，メソッドがフィールドを更新するかアクセスするなら，間違いを指摘するかもしれません。\n</p>",
	"WMI_WRONG_MAP_ITERATOR":                                   "entrySet イテレータではなく効率が悪い keySet イテレータを使用している\n\n<p>\nこのメソッドは， <code>keySet</code> イテレータから取り出されたキーを使用して，マップエントリの値にアクセスしています。\n<code>Map</code> の <code>entrySet</code> イテレータを使用したほうが <code>Map.get(key)</code> ルックアップを回避するのでより効率的です。\n</p>",
	"ISC_INSTANTIATE_STATIC_CLASS":                             "static メソッドだけを提供するクラスの不必要なインスタンス化\n\n<p>\nこのクラスは， <code>static</code> メソッドだけを提供するクラスのオブジェクトを作成しています。\nこのオブジェクトは作成する必要はありません。修飾子として直接クラス名を使用する <code>static</code> メソッドにアクセスしてください。\n</p>",
	"REC_CATCH_EXCEPTION":                                      "例外がスローされないのに例外をキャッチしている\n\n<p>\nこのメソッドは，例外オブジェクトをキャッチする <code>try-catch</code> ブロックを使用していますが，例外は <code>try</code> ブロックの中でスローされません。また，実行時例外は明示的にキャッチされません。\nそれぞれの <code>catch</code> ブロックが同一である多くの例外型をキャッチすることの短縮形として <code>try { ... } catch (Exception e) { something }</code> を使用することが共通のバグパターンです。\nしかし，この構文は誤って実行時例外も同様にキャッチするので，潜在的なバグを隠します。\n</p>\n<p>\nより良いアプローチは，明示的にキャッチするよりもスローされる特定の例外をスローします。\nまたは，次に示すように明示的に <code>RuntimeException</code> をキャッチ，再スローして，非実行時例外をキャッチします。\n</p>\n<pre><code>try {\n    ...\n} catch (RuntimeException e) {\n    throw e;\n} catch (Exception e) {\n    ... deal with all non-runtime exceptions ...\n}\n</code></pre>",
	"FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER":                         "NaN への等価性のための絶望的なテスト\n\n<p>\nこのコードは浮動小数点が特別な非数値と等価であるか確かめています (たとえば <code>if (x == Double.NaN)</code>)。\nしかしながら， <code>NaN</code> の特別な意味のため，値は <code>NaN</code> と等価ではありません。\nしたがって， <code>x == Double.NaN</code> は常に <code>false</code> と評価します。\n<code>x</code> という値が特別な非数値であるかどうか確かめるためには <code>Double.isNaN(x)</code> を使用します (または <code>x</code> が浮動小数点精度であるなら <code>Float.isNaN(x)</code>)。\n</p>",
	"FE_FLOATING_POINT_EQUALITY":                               "浮動小数点の等価性のためのテスト\n\n<p>\nこの演算は，等価性のために2つの浮動小数点値を比較しています。\n浮動小数点の計算は丸めを伴うかもしれないので計算された <code>float</code> と <code>double</code> の値は正確ではないかもしれません。\n通貨のような正確でなければならない値のために <code>BigDecimal</code> のような固定精度型を使用することを検討してください。\n正確である必要がない値のためにいくつかの範囲の中で等価性のために比較することを検討してください。\nたとえば， <code>if (Math.abs(x - y) &lt; .0000001)</code>。<br>\n詳細は Java 言語仕様4.2.4を参照してください。\n</p>",
	"UM_UNNECESSARY_MATH":                                      "定数値で Math クラスの static メソッドを呼び出しているメソッド\n\n<p>\nこのメソッドは，定数値で <code>java.lang.Math</code> の <code>static</code> メソッドを呼び出しています。\nこのメソッドの結果は静的に判定でき，より高速で，ときには定数を使用するほうがより正確です。<br>\n検出されるメソッドは，次のとおりです。\n</p>\n<table>\n<tr><th>メソッド</th>                  <th>パラメータ</th></tr>\n<tr><td><code>abs</code></td>       <td>-any-</td></tr>\n<tr><td><code>acos</code></td>      <td>0.0 or 1.0</td></tr>\n<tr><td><code>asin</code></td>      <td>0.0 or 1.0</td></tr>\n<tr><td><code>atan</code></td>      <td>0.0 or 1.0</td></tr>\n<tr><td><code>atan2</code></td>     <td>0.0</td></tr>\n<tr><td><code>cbrt</code></td>      <td>0.0 or 1.0</td></tr>\n<tr><td><code>ceil</code></td>      <td>-any-</td></tr>\n<tr><td><code>cos</code></td>       <td>0.0</td></tr>\n<tr><td><code>cosh</code></td>      <td>0.0</td></tr>\n<tr><td><code>exp</code></td>       <td>0.0 or 1.0</td></tr>\n<tr><td><code>expm1</code></td>     <td>0.0</td></tr>\n<tr><td><code>floor</code></td>     <td>-any-</td></tr>\n<tr><td><code>log</code></td>       <td>0.0 or 1.0</td></tr>\n<tr><td><code>log10</code></td>     <td>0.0 or 1.0</td></tr>\n<tr><td><code>rint</code></td>      <td>-any-</td></tr>\n<tr><td><code>round</code></td>     <td>-any-</td></tr>\n<tr><td><code>sin</code></td>       <td>0.0</td></tr>\n<tr><td><code>sinh</code></td>      <td>0.0</td></tr>\n<tr><td><code>sqrt</code></td>      <td>0.0 or 1.0</td></tr>\n<tr><td><code>tan</code></td>       <td>0.0</td></tr>\n<tr><td><code>tanh</code></td>      <td>0.0</td></tr>\n<tr><td><code>toDegrees</code></td> <td>0.0 or 1.0</td></tr>\n<tr><td><code>toRadians</code></td> <td>0.0</td></tr>\n</table>",
	"CD_CIRCULAR_DEPENDENCY":                                   "クラス間の循環依存関係のテスト\n\n<p>\nこのクラスは，他のクラスと循環依存関係があります。\nそれぞれが他のクラスの正確な構築に依存していて，クラスの構築を難しくしています。\n難しい依存関係を断つためにインタフェースの使用を検討してください。\n</p>",
	"RI_REDUNDANT_INTERFACES":                                  "スーパークラスと同じインタフェースを実装しているクラス\n\n<p>\nこのクラスは，スーパークラスによっても実装されるインタフェースを実装することを宣言しています。\nスーパークラスがインタフェースを実装するので，これは冗長です。デフォルトですべてのサブクラスもこのインタフェースを実装します。\nこのクラスが作成されてから継承階層が変わったことを指摘するかもしれません。インタフェースの実装の所有権を考慮すべきです。\n</p>",
	"MTIA_SUSPECT_STRUTS_INSTANCE_FIELD":                       "Struts Action を拡張したクラスでのインスタンス変数の使用\n\n<p>\nStruts Action クラスを拡張したクラスで，インスタンス変数を使用しています。\nStruts Action クラスの1つのインスタンスだけが Struts フレームワークによって作成され，マルチスレッドによって使われるので，このパラダイムは極めて問題があり，推奨できません。\nローカル変数を使用することだけを検討してください。\nモニタを除いて書き込まれるインスタンスフィールドだけが報告されます。\n</p>",
	"MTIA_SUSPECT_SERVLET_INSTANCE_FIELD":                      "Servlet クラスを拡張したクラスでのインスタンス変数の使用\n\n<p>\n<code>Servlet</code> クラスを拡張したクラスで，インスタンス変数を使用しています。\n<code>Servlet</code> クラスの1つのインスタンスだけが Java EE フレームワークによって作成され，マルチスレッドによって使われるので，このパラダイムは極めて問題があり，推奨できません。\nローカル変数を使用することだけを検討してください。\n</p>",
	"PS_PUBLIC_SEMAPHORES":                                     "公開インタフェースで同期化とセマフォを暴露するクラス\n\n<p>\nこのクラスは，自分自身 (<code>this</code> 参照) で， <code>wait</code> メソッド， <code>notify</code> メソッド， <code>notifyAll</code> メソッド とともに同期化しています。\nこのクラスを使用するクライアントクラスは，同期化のためのオブジェクトとしてこのクラスのインスタンスをさらに使用するかもしれません。\n2つのクラスが同期化のために同じオブジェクトを使用するので，マルチスレッドの正確性は疑わしいです。\n公開参照で同期化もセマフォメソッドの呼び出しもすべきではありません。\n同期化の制御には内部の公開されないメンバ変数を使用することを検討してください。\n</p>",
	"ICAST_INTEGER_MULTIPLY_CAST_TO_LONG":                      "整数乗算の結果を long にキャストしている\n\n<p>\nこのコードは次のように整数の乗算を実行してから結果を <code>long</code> に変換しています。\n</p>\n<pre><code>long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; }\n</code></pre>\n<p>\n<code>long</code> を使用して乗算をすれば，結果がオーバーフローするという可能性を回避できます。<br>\nたとえば次のように修正できます。\n</p>\n<pre><code>long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; }\n</code></pre>\n<p>\nまたは\n</p>\n<pre><code>static final long MILLISECONDS_PER_DAY = 24L*3600*1000;\nlong convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }\n</code></pre>",
	"ICAST_INT_2_LONG_AS_INSTANT":                              "int 値を long に変換して絶対時間として使用している\n\n<p>\nこのコードは32ビット int 値を64ビット long 値に変換して，絶対時間値を必要とするメソッドパラメータに渡しています。\n絶対時間値は，「エポック」（すなわち，1970年1月1日，00:00:00 GMT）としてわかっている標準的な基準時間からのミリ秒数です。<br>\nたとえば，エポックからの秒を <code>Date</code> へ変換することを意図した次のメソッド はひどく壊れています。\n</p>\n<pre><code>Date getDate(int seconds) { return new Date(seconds * 1000); }\n</code></pre>\n<p>\n乗算は32ビット演算を使用して，64ビット値に変換されます。\n32ビット値は，64ビットに変換されて，絶対時間値を表すために使用されるとき，1969年12月と1970年1月の日付しか表せません。\n</p>\n<p>\n上記のメソッドの正しい実装は次のとおりです。\n</p>\n<pre><code>// 失敗，2037年後の日付\nDate getDate(int seconds) { return new Date(seconds * 1000L); }\n\n// より良い，すべての日付で動作する\nDate getDate(long seconds) { return new Date(seconds * 1000); }\n</code></pre>",
	"ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND":                  "整数値を float にキャストして Math.round() に渡している\n\n<p>\nこのコードは整数値を <code>float</code> 精度浮動小数点に変換してから，その結果を <code>Math.round()</code> に渡して引数に最も近い <code>int</code>/<code>long</code> を返します。\n整数を <code>float</code> に変換すると小数部がない数値が得られるので，この演算は常にノーオペレーションになります。\n<code>Math.round()</code>に渡される値を生成した演算が浮動小数点演算を使用して実行することを意図した可能性が高いです。\n</p>",
	"ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL":                  "整数値を double にキャストして Math.ceil() に渡している\n\n<p>\nこのコードは整数値 (たとえば， <code>int</code> や <code>long</code>) を倍精度浮動小数点に変換してから，その結果を <code>Math.ceil()</code> に渡しています。\n整数を <code>double</code> に変換すると小数部がない数値が得られるので，この演算は常にノーオペレーションになります。\n<code>Math.ceil()</code>に渡される値を生成した演算が倍精度浮動小数点演算を使用して実行することを意図した可能性が高いです。\n</p>",
	"ICAST_IDIV_CAST_TO_DOUBLE":                                "整数の除算の結果を double または float にキャストしている\n\n<p>\nこのコードは整数の除算の結果を <code>double</code> または <code>float</code> にキャストしています。\n整数で除算をすることは，ゼロに最も近い整数値まで結果を切り捨てます。\n結果が <code>double</code> にキャストされたという事実は，この精度が維持されるべきだったことを示唆しています。\nおそらく意味されたことは，除算を実行する前にオペランドの1つまたは両方を <code>double</code> にキャストすることでした。<br>\n次に例を示します。\n</p>\n<pre><code>int x = 2;\nint y = 5;\n// Wrong: yields result 0.0\ndouble value1 = x / y;\n\n// Right: yields result 0.4\ndouble value2 = x / (double) y;\n</code></pre>",
	"J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION":       "HttpSession への非直列化可能オブジェクトの格納\n\n<p>\nこのコードは <code>HttpSession</code> に非直列化可能オブジェクトを格納していると思われます。\nこのセッションが不活性化されるか移行したなら，エラーを招きます。\n</p>",
	"DMI_NONSERIALIZABLE_OBJECT_WRITTEN":                       "ObjectOutput に書き込まれる非直列化可能オブジェクト\n\n<p>\nこのコードは <code>ObjectOutput.writeObject</code> に非直列化可能オブジェクトを渡していると思われます。\nこのオブジェクトが本当に非直列化可能なら，エラーを招きます。\n</p>",
	"VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT":                    "書式文字列ための前の引数がない\n\n<p>\nこの書式文字列は前の書式指示子の引数が再利用されるようにするために「相対インデックス (<code>&lt;</code>)」を指定しています。\nしかしながら，前の引数がありません。\nたとえば， <code>formatter.format(\"%&lt;s %s\", \"a\", \"b\")</code> が実行されると <code>MissingFormatArgumentException</code> をスローします。\n</p>",
	"VA_FORMAT_STRING_USES_NEWLINE":                            "書式文字列は \n よりも %n を使用すべき\n\n<p>\nこの書式文字列は改行文字 (<code>\n</code>) が含まれています。\n一般的に書式文字列には <code>%n</code> を使用することがより望ましいです。<code>%n</code> は，プラットフォーム特有の行セパレータを作り出します。\n</p>",
	"VA_FORMAT_STRING_BAD_CONVERSION":                          "与えられた引数の型は書式指示子に合致しない\n\n<p>\n引数の1つは対応する書式指示子と互換性がありません。その結果，実行されるときに実行時例外を生成します。\nたとえば， <code>String.format(\"%d\", \"1\")</code> は，文字列 \"1\" が書式指示子 <code>%d</code> と互換性がないので例外を生成します。\n</p>",
	"VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN":               "Boolean 型ではない引数を ％b 書式指示子を使用してフォーマットしている\n\n<p>\n<code>Boolean</code> 型ではない引数を <code>%b</code> 書式指示子でフォーマットしています。これは例外をスローしません。\nその代わりに，非 <code>null</code> 値では <code>true</code> ， <code>null</code> では <code>false</code> を出力します。\n書式文字列のこの機能は奇妙で意図したことではないかもしれません。\n</p>",
	"VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY":               "書式文字列を使用して役に立たない方法で配列をフォーマットしている\n\n<p>\n書式文字列でフォーマットされている引数の1つは配列です。\n実際には配列の内容を表示しない [I@304282 のような，かなり役に立たない書式を使用してフォーマットされます。\nフォーマットで扱う前に <code>Arrays.asList(...)</code> を使用して配列をラップすることを検討してください。\n</p>",
	"VA_FORMAT_STRING_ARG_MISMATCH":                            "書式文字列への引数の数と書式指示子の数が一致していない\n\n<p>\n可変長引数による書式文字列メソッドが呼び出されていますが渡された引数の数と書式文字列の中の % 書式指示子の数が一致していません。\nこれはおそらく作成者の意図したことではありません。\n</p>",
	"VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED":        "printf スタイルの書式が期待されているところで MessageFormat が与えられている\n\n<p>\nJava の <code>printf</code> 書式文字列と引数のリストを期待するメソッドが呼び出されています。\nしかしながら，書式文字列にはどんな書式指示子 (たとえば， <code>%s</code>) も含まないで，メッセージフォーマットの要素 (たとえば， <code>{0}</code>) を含んでいます。\n<code>printf</code> スタイルの書式文字列が必要なときに， <code>MessageFormat</code> の文字列を与えている可能性が高いです。\n実行時に，すべての引数は無視され，書式文字列は正確にフォーマットされずに返されます。\n</p>",
	"VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED":                  "書式文字列で実際に使われるよりも多くの引数が渡されている\n\n<p>\n可変長引数による書式文字列メソッドが呼び出されていますが，書式文字列で実際に使われるよりも多くの引数が渡されています。\nこれは実行時例外の原因とはなりませんが，コードはフォーマットされた文字列に含まれることを意図した情報を黙って省略しているかもしれません。\n</p>",
	"VA_FORMAT_STRING_ILLEGAL":                                 "無効な書式文字列\n\n<p>\n書式文字列は構文的に無効です。この文が実行されると実行時例外が発生します。\n</p>",
	"VA_FORMAT_STRING_MISSING_ARGUMENT":                        "書式文字列は足りない引数を参照している\n\n<p>\n書式文字列で書式指示子を満たすために十分な引数が渡されていません。この文が実行されると実行時例外が発生します。\n</p>",
	"VA_FORMAT_STRING_BAD_ARGUMENT":                            "書式指示子へ渡している引数に互換性がない\n\n<p>\n書式指示子は，対応する引数と互換性がありません。\nたとえば， <code>System.out.println(\"%d\n\", \"hello\");</code> の <code>%d</code> 書式指示子は数値の引数を必要としますが数値ではなく文字列が渡されています。\nこの文が実行されると実行時例外が発生します。\n</p>",
	"VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG":               "可変長引数を期待しているメソッドにプリミティブ型の配列を渡している\n\n<p>\nこのコードは可変長引数をとるメソッドにプリミティブ型の配列を渡しています。\nこれはプリミティブ型の配列を保持するために長さが1の配列を作成してメソッドに渡します。\n</p>",
	"BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS":             "equals メソッドは引数の型を仮定すべきではない\n\n<p>\n<code>equals(Object o)</code> メソッドは， <code>o</code> の型についてどんな仮定もするべきではありません。\n<code>o</code> が <code>this</code> と同じ型ではないなら単に <code>false</code> を返すべきです。\n</p>",
	"BC_BAD_CAST_TO_ABSTRACT_COLLECTION":                       "抽象コレクションへの疑わしいキャスト\n\n<p>\nこのコードは <code>Collection</code> を抽象コレクションにキャストしています (たとえば <code>List</code> ， <code>Set</code> ， <code>Map</code>)。\nオブジェクトがキャストする型であるということが保証されていることを確認してください。\n必要とするコレクションの反復処理ができるなら <code>Set</code> または <code>List</code> にキャストする必要はありません。\n</p>",
	"BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY":                       "プリミティブ型の配列を含んでいる不可能なキャスト\n\n<p>\nこのキャストは，常に <code>ClassCastException</code> をスローします。\n</p>",
	"BC_IMPOSSIBLE_CAST":                                       "不可能なキャスト\n\n<p>\nこのキャストは，常に <code>ClassCastException</code> をスローします。\nSpotBugs は， <code>instanceof</code> チェックから型情報を調査して，メソッドからの戻り値とフィールドからロードされた値の型について，より多くの正確な情報を使用します。\nしたがって，宣言された変数の型にはより多くの正確な情報があるかもしれないしれません。\nまた，キャストが常に実行時例外をスローするのかを決定するために利用する可能性があります。\n</p>",
	"BC_IMPOSSIBLE_DOWNCAST":                                   "不可能なダウンキャスト\n\n<p>\nこのキャストは，常に <code>ClassCastException</code> をスローします。\n解析は，キャストしている値の正確な型がわかっていると信じていて，サブタイプへダウンキャストしようとする試みは， <code>ClassCastException</code> のスローによって常に失敗します。\n</p>",
	"BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY":                        "toArray メソッドの結果の不可能なダウンキャスト\n\n<p>\nこのコードは <code>toArray</code> メソッドの呼び出し結果を <code>Object[]</code> ではなく具体的な型のコレクションでキャストしています。\n</p>\n<pre><code>String[] getAsArray(Collection&lt;String&gt; c) {\n    return (String[]) c.toArray();\n}\n</code></pre>\n<p>\nこれは通常 <code>ClassCastException</code> をスローして失敗します。\nほとんどすべてのコレクションの <code>toArray</code> メソッドは， <code>Object[]</code> を返します。\n<code>Collection</code> オブジェクトは宣言された総称型コレクションの参照がないので，本当に何もできません。\nコレクションから特定の型の配列を得る正しい方法は， <code>c.toArray(new String[]);</code> または <code>c.toArray(new String[c.size()]);</code> (後者はわずかにより効率的です) を使用することです。\nこれに対する1つの共通の知られている例外があります。\n<code>Arrays.asList(...)</code>によって返されるリストの <code>toArray()</code> メソッドは共変型配列を返します。\nたとえば， <code>Arrays.asArray(new String[] { \"a\" }).toArray()</code> は <code>String []</code> を返します。\nSpotBugs はそのようなケースを検出して抑止しようとしますが，見落としているかもしれません。\n</p>",
	"NP_NULL_INSTANCEOF":                                       "null とわかっている値をその型のインスタンスなのか確かめている\n\n<p>\nチェックされている値が <code>null</code> であることが保証されているので， <code>instanceof</code> は常に <code>false</code> を返します。\nこれは安全で，誤解や論理エラーを指摘していないことを確認してください。\n</p>",
	"BC_NULL_INSTANCEOF":                                       "A known null value is checked to see if it is an instance of a type\n\n<p>\nThis instanceof test will always return false, since the value being checked is guaranteed to be null.\nAlthough this is safe, make sure it isn't\nan indication of some misunderstanding or some other logic error.\n</p>",
	"BC_IMPOSSIBLE_INSTANCEOF":                                 "常に false を返す instanceof\n\n<p>\nこの <code>instanceof</code> は常に <code>false</code> を返します。これは安全で，誤解や論理エラーを指摘していないことを確認してください。\n</p>",
	"BC_VACUOUS_INSTANCEOF":                                    "常に true を返す instanceof\n\n<p>\nこの <code>instanceof</code> は常に <code>true</code> を返します (テストしている値が <code>null</code> ではないかぎり)。\nこれは安全で，誤解や論理エラーを指摘していないことを確認してください。\n本当に <code>null</code> なのか値をテストしたいなら，多分， <code>instanceof</code> ではなく <code>null</code> テストをしたほうが良く，より明確になります。\n</p>",
	"BC_UNCONFIRMED_CAST":                                      "未チェック/未確認のキャスト\n\n<p>\nこのキャストはチェックされていません。すべての型のインスタンスをキャストする型へキャストできるわけではありません。\nプログラムのロジックがこのキャストが失敗しないことを確実に確認してください。\n</p>",
	"BC_UNCONFIRMED_CAST_OF_RETURN_VALUE":                      "メソッドからの戻り値の未チェック/未確認のキャスト\n\n<p>\nこのコードはメソッドの戻り値の未確認のキャストを実行しています。\nコードは，キャストが安全であることが保証されるようにメソッドを呼び出しているかもしれませんが，SpotBugs はキャストが安全であることを検証できません。\nプログラムのロジックがこのキャストが失敗しないことを確実に確認してください。\n</p>",
	"BC_BAD_CAST_TO_CONCRETE_COLLECTION":                       "具象コレクションへの疑わしいキャスト\n\n<p>\nこのコードは抽象コレクション (たとえば， <code>Collection</code> ， <code>List</code> ， <code>Set</code>) を特定の具象実装 (たとえば， <code>ArrayList</code> ， <code>HashSet</code>) にキャストしています。\nこれは正しくないかもしれません。そして，将来の時点で他の具象実装への切り替えをとても困難にするので，脆弱なコードになるかもしれません。\nそうするための特別な理由がないかぎり抽象コレクションクラスを使用してください。\n</p>",
	"RE_POSSIBLE_UNINTENDED_PATTERN":                           "正規表現のために使われている \".\" または \"|\"\n\n<p>\n<code>String</code> 機能が呼び出されていて， <code>.</code> または <code>|</code> が引数として正規表現を取るパラメータに渡されています。\nこれは意図したことですか?\nたとえば\n</p>\n<ul>\n  <li><code>s.replaceAll(\".\", \"/\")</code> は，すべての文字が '/' 文字に置換された <code>String</code> を返す</li>\n  <li><code>s.split(\".\")</code> は，常に長さが0の <code>String</code> 配列を返す</li>\n  <li><code>\"ab|cd\".replaceAll(\"|\", \"/\")</code> は，\"/a/b/|/c/d/\" を返す</li>\n  <li><code>\"ab|cd\".split(\"|\")</code> は，6個の要素がある配列を返す: [, a, b, |, c, d]</li>\n</ul>",
	"RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION":                     "正規表現のための無効な構文\n\n<p>\nこのコードは正規表現の構文によると無効である正規表現を使用しています。\nこの文が実行されるとき <code>PatternSyntaxException</code> をスローします。\n</p>",
	"RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION":         "正規表現のために使われている File.separator\n\n<p>\nこのコードは正規表現が必要な場所で， <code>File.separator</code> を使用しています。\nこれは <code>File.separator</code> がバックスラッシュである Windows プラットフォームでは失敗します。\nバックスラッシュは正規表現ではエスケープ文字として解釈されます。\nその他の選択肢としては， <code>File.separator</code> の代わりに <code>File.separatorChar=='\\' ? \"\\\\\" : File.separator</code> を使用できます。\n</p>",
	"DLS_OVERWRITTEN_INCREMENT":                                "上書きされたインクリメント\n\n<p>\nこのコードはインクリメント演算 (たとえば， <code>i++</code>) を実行してすぐに上書きしています。\nたとえば， <code>i = i++</code> は元の値をインクリメントした値で上書きします。\n</p>",
	"ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT":                  "符号なし右シフトを short/byte にキャストしている\n\n<p>\nこのコードは符号なしキャストの実行結果を <code>short</code> または <code>byte</code> にキャストしています。結果の上位ビットは捨てられます。\n上位ビットが捨てられるので，符号付きと符号なし右シフト (シフトのサイズによって) との違いがないかもしれません。\n</p>",
	"BSHIFT_WRONG_ADD_PRIORITY":                                "シフト演算の正しくない構文解析の可能性がある\n\n<p>\nコードは <code>(x &lt;&lt; 8 + y)</code> のような演算を行います。\nこれは正しいかもしれませんが，おそらく <code>(x &lt;&lt; 8) + y</code> を行うことを意図していました。\nしかし，シフト演算は優先順位が低いので，実際には <code>x &lt;&lt; (8 + y)</code> として構文解析されます。\n</p>",
	"ICAST_BAD_SHIFT_AMOUNT":                                   "32ビット int の-31から31の範囲を超えた量によるシフト\n\n<p>\nこのコードは32ビット int の-31から31の範囲を超えた量でシフトを実行しています。\nこれの効果は，どのくらいシフトするのかを決めるために整数値の下位5ビット (32で割った余り) を使用することです (たとえば，40ビットでシフトすることは8ビットでシフトすることと同じで，32ビットでシフトすることは0ビットでシフトすることと同じです)。\nこれはおそらく期待されたことではなく，少なくとも紛らわしいです。\n</p>",
	"IM_MULTIPLYING_RESULT_OF_IREM":                            "整数剰余の結果の整数乗算\n\n<p>\nこのコードは整数剰余の結果に整数定数を乗算しています。\n紛らわしい演算子の優先順位がないことを確実にしてください。\nたとえば， <code>i % 60 * 1000</code> は， <code>i % (60 * 1000)</code> ではなく <code>(i % 60) * 1000</code> となります。\n</p>",
	"DMI_INVOKING_HASHCODE_ON_ARRAY":                           "配列で hashCode メソッドを呼び出している\n\n<p>\nこのコードは配列で <code>hashCode</code> メソッドを呼び出しています。\n配列で <code>hashCode</code> メソッドを呼び出すことは， <code>System.identityHashCode</code> と同じ値を返すので，内容と配列の長さを無視します。\n配列 <code>a</code> の内容によるハッシュコードを必要とするなら， <code>java.util.Arrays.hashCode(a)</code> を使用してください。\n</p>",
	"DMI_INVOKING_TOSTRING_ON_ARRAY":                           "配列で toString メソッドを呼び出している\n\n<p>\nこのコードは配列で <code>toString</code> メソッドを呼び出しています。「[C@16f0472」のようなかなり役に立たない結果を生成します。\n<code>Arrays.toString()</code> を使用して，配列の内容を読み取り可能な文字列に変換することを検討してください。<br>\n『Programming Puzzlers』の第3章，パズル12を参照してください。\n</p>",
	"DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY":                 "名前のない配列で toString メソッドを呼び出している\n\n<p>\nこのコードは無名の配列で <code>toString</code> メソッドを呼び出しています。「[C@16f0472」のようなかなり役に立たない結果を生成します。\n<code>Arrays.toString()</code> を使用して，配列の内容を読み取り可能な文字列に変換することを検討してください。<br>\n『Programming Puzzlers』の第3章，パズル12を参照してください。\n</p>",
	"IM_AVERAGE_COMPUTATION_COULD_OVERFLOW":                    "平均の計算はオーバーフローする可能性がある\n\n<p>\nこのコードは除算か符号付き右シフトを使用して2つの整数の平均を計算して，結果を配列の添字として使用しています。\n平均値が非常に大きいならオーバーフローする可能性があります (結果として負の平均の計算になる)。\n結果が負ではないことを意図していたなら，その代わりに符号なし右シフトを使用できます。\nつまり， <code>(low+high)/2</code> ではなく <code>(low+high) &gt;&gt;&gt; 1</code> を使用してください。\n</p>\n<p>\nこのバグは，二分探索とマージソートの多くの以前の実装で存在します。\nMartin Buchholz が <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6412541\">JDK ライブラリのバグを発見して修正しています</a>。\nJoshua Bloch が <a href=\"http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\">バグパターンとして公表しました</a>。\n</p>",
	"IM_BAD_CHECK_FOR_ODD":                                     "負数で機能しない奇数チェック\n\n<p>\nこのコードは <code>x % 2 == 1</code> を使用して値が負数なのか確かめていますが，負数 (たとえば， <code>(-5) % 2 == -1</code>) なので機能しません。\n奇数チェックを意図しているなら， <code>x &amp; 1 == 1</code> または <code>x % 2 != 0</code> を使用することを検討してください。\n</p>",
	"DMI_HARDCODED_ABSOLUTE_FILENAME":                          "ハードコードされた絶対パス名への参照がある\n\n<p>\nこのコードはハードコードされた絶対パス名を使用して <code>File</code> オブジェクトを構築しています (たとえば <code>new File(\"/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment\");</code>)。\n</p>",
	"DMI_BAD_MONTH":                                            "月のための間違った定数値\n\n<p>\nこのコードはメソッドに0から11の範囲外の月定数値を渡しています。\n</p>",
	"DMI_USELESS_SUBSTRING":                                    "substring(0) の呼び出しは元の値を返す\n\n<p>\nこのコードは文字列で <code>substring(0)</code> を呼び出していますが，元の値を返します。\n</p>",
	"DMI_CALLING_NEXT_FROM_HASNEXT":                            "hasNext メソッドで next メソッドを呼び出している\n\n<p>\n<code>hasNext</code> メソッドは， <code>next</code> メソッドを呼び出しています。\n<code>hasNext</code> メソッドは，イテレータの状態を変更することになっていないので，ほぼ確実に間違っています。\n<code>next</code> メソッドがイテレータの状態を変更することになっています。\n</p>",
	"SWL_SLEEP_WITH_LOCK_HELD":                                 "ロックを保持して Thread.sleep() を呼び出しているメソッド\n\n<p>\nこのメソッドは，ロックを保持して， <code>Thread.sleep()</code> を呼び出しています。\n他のスレッドがロックを獲得するために待機しているかもしれないので，ひどい性能とスケーラビリティ，またはデッドロックの原因になるかもしれません。\nロックで <code>wait</code> メソッドを呼び出すことはかなり良い考えで，ロックを解除して他のスレッドが実行するのを許可します。\n</p>",
	"DB_DUPLICATE_BRANCHES":                                    "2つの分岐のために同じコードを使用しているメソッド\n\n<p>\nこのメソッドは，条件分岐の2つの分岐を実装するために同じコードを使用しています。これがコーディングミスではないことを確認してください。\n</p>",
	"DB_DUPLICATE_SWITCH_CLAUSES":                              "switch 文の2つの case のために同じコードを使用しているメソッド\n\n<p>\nこのメソッドは， <code>switch</code> 文の2つの <code>case</code> を実装するために同じコードを使用しています。\n複製コードの <code>case</code> かもしれないし，コーディングミスかもしれません。\n</p>",
	"IMA_INEFFICIENT_MEMBER_ACCESS":                            "所有クラスの private メンバ変数にアクセスしているメソッド\n\n<p>\nこの内部クラスのメソッドは，所有クラスの <code>private</code> メンバ変数への読み書きか，所有クラスの <code>private</code> メソッドを呼び出しています。\nコンパイラはこの <code>private</code> メンバにアクセスするための特別なメソッドを生成しなければなりないので，効率を悪化させる原因になります。\nメンバ変数またはメソッドの保護を緩和することは，コンパイラが正常なアクセスとして扱うのを許可します。\n</p>",
	"XFB_XML_FACTORY_BYPASS":                                   "XMLインタフェースの特定の実装のインスタンスを作成しているメソッド\n\n<p>\nこのメソッドは，XMLインタフェースの特定の実装のインスタンスを作成しています。\n提供されたファクトリクラスを使用してオブジェクトを作成して実行時に実装を変更できるようにすることが望ましいです。<br>\n詳細は，次を参照してください。\n</p>\n<ul>\n  <li><code>javax.xml.parsers.DocumentBuilderFactory</code></li>\n  <li><code>javax.xml.parsers.SAXParserFactory</code></li>\n  <li><code>javax.xml.transform.TransformerFactory</code></li>\n  <li><code>org.w3c.dom.Document.createXXXX</code></li>\n</ul>",
	"USM_USELESS_SUBCLASS_METHOD":                              "親クラスのメソッドに過剰に委譲しているメソッド\n\n<p>\nこの派生メソッドは，単に受け取られる正確なパラメータを渡している同じスーパークラスのメソッドを呼び出すだけです。\nこのメソッドは，付加価値が与えられないので除去できます。\n</p>",
	"USM_USELESS_ABSTRACT_METHOD":                              "実装されたインタフェースで既に定義された抽象メソッド\n\n<p>\nこの抽象メソッドは，この抽象クラスによって実装されるインタフェースで既に定義されています。\nこのメソッドは，付加価値が与えられないので除去できます。\n</p>",
	"CI_CONFUSED_INHERITANCE":                                  "final なクラスが protected フィールドを宣言している\n\n<p>\nこのクラスは， <code>final</code> と宣言されていますが，フィールドは <code>protected</code> と宣言されています。\nクラスは <code>fainal</code> なので派生できません。<code>protected</code> の使用は紛らわしいです。\nフィールドのためのアクセス修飾子は，フィールドの真の用途を表すため， <code>private</code> か <code>public</code> に変更すべきです。\n</p>",
	"QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT":                      "論理式で boolean リテラル値を代入しているメソッド\n\n<p>\nこのメソッドは， <code>if</code> または <code>while</code> の式の中の <code>boolean</code> 変数に <code>boolean</code> リテラル値 (<code>true</code> または <code>false</code>) を代入しています。\nおそらく，これは <code>=</code> による代入ではなく， <code>==</code> を使用して論理比較をすることになっていました。\n</p>",
	"VR_UNRESOLVABLE_REFERENCE":                                "解決できないクラス，メソッドへの参照\n\n<p>\nこのクラスは，解析されているライブラリに対して解決されないクラスまたはメソッドを参照しています。\n</p>",
	"GC_UNCHECKED_TYPE_IN_GENERIC_CALL":                        "検査されない型への総称呼び出し\n\n<p>\n総称型パラメータからの特定の型が予想される <code>Object</code> 型をコンパイルするとき，総称型コレクションメソッドへの呼び出しは引数を渡します。\nしたがって，標準の Java 型システムも静的解析もパラメータとして渡されているオブジェクトが適切な型かどうかに関する有用な情報を提供できません。\n</p>",
	"GC_UNRELATED_TYPES":                                       "型パラメータとメソッド引数に関係がない\n\n<p>\n総称型コレクションメソッドへの呼び出しにコレクションのパラメータとは互換性のないクラスの引数があります (すなわち，引数の型は総称型引数に対応するスーパタイプでもサブタイプでもありません)。\nしたがって，コレクションにはここで使用されたメソッド引数と等価であるどんなオブジェクトも含まれていません。\n多分間違った値がメソッドに渡されています。\n一般的に2つの無関係なクラスのインスタンスは等価ではありません。\nたとえば， <code>Foo</code> と <code>Bar</code> クラスがサブタイプによって関係がないなら， <code>Foo</code> のインスタンスは <code>Bar</code> のインスタンスと等価のはずがありません。\nその他の問題で対称的ではない <code>equals</code> メソッドになる可能性が高いです。\nたとえば， <code>Foo</code> が <code>String</code> と等価であるように <code>Foo</code> クラスを定義するなら， <code>String</code> は <code>String</code> だけと等価であるので， <code>equals</code> メソッドは対称的ではありません。\n</p>\n<p>\nまれに，非対称 <code>equals</code> メソッドを定義して，まだ，何とかそれらのコードを機能させています。\nAPIのどれも文書化していないか，保証もしていないが， <code>Collection&lt;String&gt;</code> に <code>Foo</code> があるかどうか調べたいなら，\n引数の <code>equals</code> メソッド (たとえば， <code>Foo</code>クラスの <code>equals</code> メソッド) を使用して等価性をチェックします。\n</p>",
	"DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES":            "コレクションは自分自身を含めるべきではない\n\n<p>\nこの総称型コレクションメソッドへの呼び出しはコレクションに自分自身が含まれている場合 (たとえば， <code>s.contains(s)</code> が <code>true</code>) にだけ意味があります。\nこれが本当だとは思えないし，もし本当なら問題の原因になります (たとえば，無限再帰になっているハッシュコードの計算)。\n間違ったパラメータが渡されている可能性が高いです。\n</p>",
	"DMI_VACUOUS_SELF_COLLECTION_CALL":                         "コレクションへの無意味な呼び出し\n\n<p>\nこの呼び出しは意味がありません。\nどんなコレクション <code>c</code> も <code>c.containsAll(c)</code> を呼び出すことは常に <code>true</code> であるべきです。\nそして， <code>c.retainAll(c)</code> は効果があるはずがありません。\n</p>",
	"PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS":                 "繰り返しでエントリオブジェクトを再利用しない\n\n<p>\nこのクラスは， <code>Iterator</code> と <code>Map.Entry</code> で基底 <code>Map</code> のビューを返すことを許可された両方の <code>entrySet</code> メソッドがあります。\nこの巧妙なアイデアは， <code>Map</code> 実装で使用されましたが，厄介なコーディングミスの可能性を取り込みました。\n<code>Map m</code> が <code>entrySet</code> のためのそのような反復子を返すならば， <code>c.addAll(m.entrySet())</code> はひどく間違っているでしょう。\nOpenJDK 1.7 の すべての <code>Map</code> 実装はこれを回避するために書き直されました。\n</p>",
	"DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS":                   "エントリセットの要素を加えることは，Entry オブジェクトの再利用のために失敗するかもしれない\n\n<p>\n<code>entrySet</code> メソッドは，一つの <code>Entry</code> オブジェクトを再利用し，反復中に返される基底 <code>Map</code> のビューを返すことが許可されています。\nJava 1.6 の時点で， <code>IdentityHashMap</code> と <code>EnumMap</code> の両方がそうしました。\nそのような <code>Map</code> を通して繰り返すとき，エントリ値は次の繰り返しへ進むまでが有効です。\nたとえば， <code>addAll</code> メソッドにそのような <code>entrySet</code> を渡そうと試みるのは，ひどく間違っているでしょう。\n</p>",
	"DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION":                  "コレクションを消去するために removeAll メソッドを使用しない\n\n<p>\nコレクション <code>c</code> からすべての要素を除去したいなら， <code>c.removeAll(c)</code> ではなく <code>c.clear</code> を使用してください。\nコレクションを消去するために <code>c.removeAll(c)</code> を呼び出すことは，それほど明確ではなく，タイプミスからの誤りに影響されやすく，効率的ではなく，いくつかのコレクションでは， <code>ConcurrentModificationException</code> をスローするかもしれません。\n</p>",
	"STCAL_STATIC_CALENDAR_INSTANCE":                           "static Calendar フィールド\n\n<p>\nたとえ JavaDoc にそれに関する手がかりがないとしても， <code>Calendar</code> はマルチスレッドでの使用は本質的に安全でありません。\n正しい同期化をしないでスレッド境界の向こうで1つのインスタンスを共有することは，アプリケーションの動作が不安定になります。\nJDK 5.0に比べて JDK 1.4 のほうが問題が表面化するように思われ，おそらく <code>sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()</code> の <code>ArrayIndexOutOfBoundsExceptions</code> や <code>IndexOutOfBoundsExceptions</code> がランダムに発生します。\n</p>\n<p>\n直列化問題も経験するかもしれません。\n</p>\n<p>\nインスタンスフィールドを使用することを推奨します。\n</p>\n<p>\n詳細については， <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579\">JDK Bug #6231579</a> や <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997\">JDK Bug #6178997</a> を参照してください。\n</p>",
	"STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE":                 "static Calendar の呼び出し\n\n<p>\nたとえ JavaDoc にそれに関する手がかりがないとしても， <code>Calendar</code> はマルチスレッドでの使用は本質的に安全ではありません。\nディテクタは， <code>static</code> フィールドから得られた <code>Calendar</code> のインスタンスの呼び出しを発見しました。\nこれは疑わしく見えます。\n</p>\n<p>\n詳細については， <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579\">JDK Bug #6231579</a> や <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997\">JDK Bug #6178997</a> を参照してください。\n</p>",
	"STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE":                 "static DateFormat フィールド\n\n<p>\nJavaDoc に書かれているように <code>DateFormat</code> はマルチスレッドでの使用は本質的に安全ではありません。\n正しい同期化をしないでスレッド境界の向こうで1つのインスタンスを共有することは，アプリケーションの動作が不安定になります。\n</p>\n<p>\n直列化問題も経験するかもしれません。\n</p>\n<p>\nインスタンスフィールドを使用することを推奨します。\n</p>\n<p>\n詳細については， <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579\">JDK Bug #6231579</a> や <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997\">JDK Bug #6178997</a> を参照してください。\n</p>",
	"STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE":              "static DateFormat の呼び出し\n\n<p>\nJavaDoc に書かれているように <code>DateFormat</code> はマルチスレッドでの使用は本質的に安全ではありません。\nディテクタは， <code>static</code> フィールドから得られた <code>DateFormat</code> のインスタンスの呼び出しを発見しました。\nこれは疑わしく見えます。\n</p>\n<p>\n詳細については， <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6231579\">JDK Bug #6231579</a> や <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6178997\">JDK Bug #6178997</a> を参照してください。\n</p>",
	"TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS":    "互換性のない型修飾子による比較値\n\n<p>\n型修飾子アノテーションを指定した値がその修飾子のない値と比較しています。\n</p>\n<p>\nより正確に， <code>when=ALWAYS</code> を指定した型修飾子アノテーションが付けられた値が同じ型修飾子で <code>when=NEVER</code> を指定する値と比較しています。\n</p>\n<p>\nたとえば， <code>@NonNegative</code> は型修飾子アノテーション <code>@Negative(when=When.NEVER)</code> の略称とします。\n次のコードは <code>return</code> 文が <code>@NonNegative</code> 値を要求するが， <code>@Negative</code> としてマークされている値を受け取るのでこの警告を生成します。\n</p>\n<pre><code>public boolean example(@Negative Integer value1, @NonNegative Integer value2) {\n    return value1.equals(value2);\n}\n</code></pre>",
	"TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED":                "型修飾子アノテーションが付けられた値がその修飾子を付けてはならない値を必要とする場所で使われている\n\n<p>\n型修飾子アノテーションが付けられた値がその修飾子を付けてはならない値を必要とする場所で使われています。\n</p>\n<p>\nより正確に， <code>when=ALWAYS</code> を指定した型修飾子アノテーションが付けられた値が到達することが保証されているか同じ型修飾子で <code>when=NEVER</code> を指定する場所で使用しています。\n</p>\n<p>\nたとえば， <code>@NonNegative</code> は型修飾子アノテーション <code>@Negative(when=When.NEVER)</code> の略称とします。\n次のコードは <code>return</code> 文が <code>＠NonNegative</code> 値を要求するが <code>＠Negative</code> としてマークされている値を受け取るのでこの警告を生成します。\n</p>\n<pre><code>public @NonNegative Integer example(@Negative Integer value) {\n    return value;\n}\n</code></pre>",
	"TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED":     "型修飾子がない値が修飾子を必要とする場所で使われている\n\n<p>\n値が型修飾子アノテーションを必要とする方法で使われています。型修飾子は厳密なので，ツールは適切なアノテーションを指定していない値を拒絶します。\n</p>\n<p>\n厳密なアノテーションを持つように値を矯正するには，戻り値に厳密なアノテーションを付ける識別関数を定義してください。\nこれはアノテーションが付けられていない値を厳密な型修飾子アノテーションを持つ値に変える唯一の方法です。\n</p>",
	"TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED":                "型修飾子アノテーションが付けられていない値がその修飾子が付けられた値を必要とする場所で使われている\n\n<p>\n型修飾子アノテーションが付けられていない値がその修飾子が付けられた値を必要とする場所で使われています。\n</p>\n<p>\nより正確に， <code>when=NEVER</code> を指定した型修飾子アノテーションが付けられた値が同じ型修飾子で <code>when=ALWAYS</code> を指定する場所で使用されています。\n</p>",
	"TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK":                "型修飾子を付けていないかもしれない値がその型修飾子を必要とする方法で常に使われている\n\n<p>\n型修飾子によって示された値のインスタンスではない可能性としてアノテーションが付けられた値です。\n値は，その型修飾子によって示された値を必要とする方法で使われることが保証されています。\n</p>",
	"TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK":                 "型修飾子を付けているかもしれない値がその型修飾子を禁止する方法で常に使われている\n\n<p>\n型修飾子によって示された値のインスタンスである可能性としてアノテーションが付けられた値です。\n値は，その型修飾子によって示された値を禁止する方法で使われることが保証されています。\n</p>",
	"TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK":      "値は型修飾子を必要としないが，不明としてマークされている\n\n<p>\n値は，型修飾子によって示された値ではないことを必要とする方法で使われています。\nしかし，値はどこでその型修飾子がいるのか禁止されていのるかわからないと述べている明示的なアノテーションがあります。\n使い方かアノテーションのどちらかが間違っています。\n</p>",
	"TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK":     "値は型修飾子を必要としているが，不明としてマークされている\n\n<p>\n値は，常に型修飾子によって示された値であることを必要とする方法で使われています。\nしかし，値はどこでその型修飾子が必要なのかわからないと述べている明示的なアノテーションがあります。\n使い方かアノテーションのどちらかが間違っています。\n</p>",
	"IO_APPENDING_TO_OBJECT_OUTPUT_STREAM":                     "オブジェクト出力ストリームへの追加は失敗に終わる\n\n<p>\nこのコードはファイルを追加モードで開いて，オブジェクト出力ストリームの中で結果をラップしています。\nこれはファイルに格納された既存のオブジェクト出力ストリームに追加できないでしょう。\nオブジェクト出力ストリームに追加したいなら，オブジェクト出力ストリームを開いておく必要があります。\n</p>\n<p>\n追加モードでファイルを開き，オブジェクト出力ストリームで書き込むことができる唯一の状況は，\nファイルを読み出すときにランダムアクセスモードで開き，追加を開始するところまでバイトオフセットをシークすると計画した場合です。\n</p>",
	"WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL":              "クラスリテラルではなく getClass で同期化している\n\n<p>\nこのインスタンスメソッドは， <code>this.getClass()</code> で同期化しています。\nこのクラスがサブクラス化されるなら，サブクラスはおそらく意図したことではないサブクラスのためにクラスオブジェクトで同期化します。\nたとえば， <code>java.awt.Label</code> の次のコードを検討してください。\n</p>\n<pre><code>private static final String base = \"label\";\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (getClass()) {\n        return base + nameCounter++;\n    }\n}\n</code></pre>\n<p>\n<code>Label</code> のサブクラスは同じサブクラスで同期化しません。データレースを生じさせます。\n代わりに，このコードは <code>Label.class</code> で同期化すべきです。\n</p>\n<pre><code>private static final String base = \"label\";\nprivate static int nameCounter = 0;\n\nString constructComponentName() {\n    synchronized (Label.class) {\n        return base + nameCounter++;\n    }\n}\n</code></pre>\n<p>\nJason Mehrens によって寄贈されたバグパターン\n</p>",
	"OBL_UNSATISFIED_OBLIGATION":                               "ストリームやリソースのクリーンアップに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，ストリーム，データベースオブジェクト，またはクリーンアップ操作を明示的に必要としている他のリソースのクリーンアップ (クローズする，片付ける) に失敗するかもしれません。\n</p>\n<p>\n一般的にメソッドがストリープや他のリソースを開いたなら，メソッドはストリームやリソースがメソッドが戻る前にクリーンアップされることを確認するために <code>try-finally</code> ブロックを使用すべきです。\n</p>\n<p>\nこのバグパターンは，OS_OPEN_STREAM と ODR_OPEN_DATABASE_RESOURCE と基本的に同じですが異なる (そして，うまくいけばより良い) 静的解析技術に基づいています。\n私たちは，このバグパターンの有効性についてのフィードバックを得ることに関心があります。\nどちらかの方法でフィードバックを送ってください。\n</p>\n<ul>\n  <li><a href=\"https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md\">問題の報告</a></li>\n  <li><a href=\"https://github.com/spotbugs/discuss/issues?q=\">メーリングリスト</a></li>\n</ul>\n<p>\n特に，このバグパターンの誤検出抑制探索法は詳細にわたって調整されていないので，誤検出についてのレポートは我々の助けになります。\n</p>\n<p>\n解析技術の説明は，Weimer と Necula による <i>Finding and Preventing Run-Time Error Handling Mistakes</i> を参照してください。\n</p>",
	"OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE":                "チェック例外でストリームやリソースのクリーンアップに失敗するかもしれないメソッド\n\n<p>\nこのメソッドは，ストリーム，データベースオブジェクト，またはクリーンアップ操作を明示的必要としている他のリソースのクリーンアップ (クローズする，片付ける) に失敗するかもしれません。\n</p>\n<p>\n一般的にメソッドがストリープや他のリソースを開いたなら，メソッドはストリームやリソースがメソッドが戻る前にクリーンアップされることを確認するために <code>try-finally</code> ブロックを使用すべきです。\n</p>\n<p>\nこのバグパターンは，OS_OPEN_STREAM と ODR_OPEN_DATABASE_RESOURCE と基本的に同じですが異なる (そして，うまくいけばより良い) 静的解析技術に基づいています。\n私たちは，このバグパターンの有効性についてのフィードバックを得ることに関心があります。\nどちらかの方法でフィードバックを送ってください。\n</p>\n<ul>\n  <li><a href=\"https://github.com/spotbugs/spotbugs/blob/master/CONTRIBUTING.md\">問題の報告</a></li>\n  <li><a href=\"https://github.com/spotbugs/discuss/issues?q=\">メーリングリスト</a></li>\n</ul>\n<p>\n特に，このバグパターンの誤検出抑制探索法は詳細にわたって調整されていないので，誤検出についてのレポートは我々の助けになります。\n</p>\n<p>\n解析技術の説明は，Weimer と Necula による <i>Finding and Preventing Run-Time Error Handling Mistakes</i> を参照してください。\n</p>",
	"FB_UNEXPECTED_WARNING":                                    "SpotBugs からの予期しない/望ましくない警告\n\n<p>\nSpotBugs は， <code>@NoWarning</code> アノテーションが付けられたことにより予期しない/望ましくない警告を生成しました。\n</p>",
	"FB_MISSING_EXPECTED_WARNING":                              "失われた SpotBugs からの予期した/望ましい警告\n\n<p>\nSpotBugs は， <code>@ExpectedWarning</code> アノテーションが付けられたことにより予期した/望ましい警告が生成されませんでした。\n</p>",
	"RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED":                   "putIfAbsent の戻り値は無視されて putIfAbsent に渡した値は再利用された\n\n<p>\n<code>putIfAbsent</code> メソッドは，1つの値が与えられたキー (非存在が成功するかどうかの第一の値) と関連することを確認するために使われます。\n戻り値を無視して，渡された値への参照を保持するなら，マップ内のキーに関連付けられていない値を保持する危険性があります。\nどれを使用するかが重要で，マップに格納されていないものを使うとプログラムは正しく動作しません。\n</p>",
	"LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE":                     "ロガーの変更は OpenJDK の弱参照が原因で潜在的に失われる\n\n<p>\nOpenJDK は，潜在的非互換性を取り入れました。特に， <code>java.util.logging.Logger</code> は振る舞いが変更されています。\n強参照を使用する代わりに弱参照を内部的に使用しています。\nこれは妥当な変更ですが，残念ながらいくつかのコードは古い振る舞いに依存しています。ロガーの構成を変更すると，ロガーへの参照が削除されます。\nこれは，ガベージコレクタが自由にそのメモリを再利用できることを意味します。つまり，ロガーの構成が失われます。<br>\nたとえば，次を検討してください。\n</p>\n<pre><code>public static void initLogging() throws Exception {\n    Logger logger = Logger.getLogger(\"edu.umd.cs\");\n    logger.addHandler(new FileHandler()); // ロガーの構成の変更\n    logger.setUseParentHandlers(false); // 別のロガーの構成の変更\n}\n</code></pre>\n<p>\nロガーの参照は，メソッドの終わり (メソッドは脱出しません) で失われるので，\n<code>initLogging</code> の呼び出しの後でガベージコレクションの循環があるなら，ロガー構成は失われます (なぜなら <code>Logger</code> は弱参照を保持するだけなので)。\n</p>\n<pre><code>public static void main(String[] args) throws Exception {\n    initLogging(); // ファイルハンドラーをロガーに追加する\n    System.gc(); // ロガーの構成が失われる\n    Logger.getLogger(\"edu.umd.cs\").info(\"Some message\"); // 期待したようにファイルに記録されません\n}\n</code></pre>\n<p>\nUlf Ochsenfahrt と Eric Fellheimer\n</p>",
	"AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION":          "並行抽象の呼び出しシーケンスはアトミックではないかもしれない\n\n<p>\nこのコードには並行抽象化 （たとえば，並行ハッシュマップ） の呼び出しシーケンスがあります。\nこれらの呼び出しはアトミックに実行されません。\n</p>",
	"DM_DEFAULT_ENCODING":                                      "デフォルトエンコーディングへの依存\n\n<p>\n<code>byte</code> から <code>String</code> (または <code>String</code> から <code>byte</code>) への変換で，デフォルトプラットフォームエンコーディングが適切だと仮定するメソッドの呼び出しを発見しました。\nこれはアプリケーションの振る舞いがプラットフォーム間で異なる原因となります。代替 API を使用して，文字セット名または <code>Charset</code> オブジェクトを明示的に指定して下さい。\n</p>",
	"NP_METHOD_PARAMETER_RELAXING_ANNOTATION":                  "メソッドはパラメータに nullness アノテーションを強化している\n\n<p>\nメソッドは，オーバーライドするメソッドの契約を常に実装すべきです。\nしたがって，メソッドが <code>@Nullable</code> としてマークされるパラメーターを取るならば，サブクラスでパラメーターを <code>@Nonnull</code> にしてメソッドをオーバーライドすべきでありません。\nそうすると，メソッドが <code>null</code> パラメータを処理する必要があるという契約に違反します。\n</p>",
	"NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION":                  "メソッドはパラメータに nullness アノテーションを強化している\n\n<p>\nメソッドは，オーバーライドするメソッドの契約を常に実装すべきです。\nしたがって，メソッドが <code>@Nullable</code> としてマークされるパラメーターを取るならば，サブクラスでパラメーターを <code>@Nonnull</code> にしてメソッドをオーバーライドすべきでありません。\nそうすると，メソッドが <code>null</code> パラメータを処理する必要があるという契約に違反します。\n</p>",
	"NP_METHOD_RETURN_RELAXING_ANNOTATION":                     "メソッドは戻り値の nullness アノテーションを緩和している\n\n<p>\nメソッドは，オーバーライドするメソッドの契約を常に実装すべきです。\nしたがって，メソッドが <code>@Nonnull</code> 値を返すようにアノテーションが付けられているならば，サブクラスでメソッドが <code>@Nullable</code> または <code>@CheckForNull</code> 値を返すようにアノテーションが付けられたメソッドをオーバーライドすべきでありません。\nそうすると，メソッドが <code>null</code> を返すべできではないという契約に違反します。\n</p>",
}
